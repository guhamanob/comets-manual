{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the online dcumentation for COMETS - Computation Of Microbial Ecosystems in Time and Space. COMETS is a software platform for performing computer simulations of spatially structured microbial communities. It is based on stoichiometric modeling of the genome-scale metabolic network of individual microbial species using dynamic flux balance analysis, and on a discrete approximation of diffusion. For more information, see Harcombe et al., Metabolic Resource Allocation in Individual Microbes Determines Ecosystem Interactions and Spatial Dynamics, Cell Reports, 2014 . COMETS is built and maintained by the Daniel Segre Lab at Boston University. COMETS is open-source software. If you are interested in contributing to the development of COMETS and would like to obtain a copy of the code, please contact us: comets@bu.edu","title":"Home"},{"location":"capabilities/","text":"The core of COMETS is the simulation of the growth of microbial populations by maximizing an objective reaction, usually biomass production, in an iterative way. An initial amount of biomass of one or more species (defined by their metaboli models) is seeded in an environment containing a list of specified nutrients. In each iteration, both the amount of biomass and the environment are updated using FBA predictions. Capabilities in space COMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds. 2D and 3D simulation \"worlds\" In addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc. Diffusive and convective propagation of biomass in space In simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined. Substrate-dependent nutrient and biomass propagation The diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc. Boundary conditions Two types of boundary conditions are implemented. Fixed value and fixed source or sink rate. Biological capabilities COMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions. Lag-phases in microbial growth Lag-phases are modelled as simulated growth activation of the colonies. Continuous (chemostat) and batch growth modes In chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency. Simulation of multispecies communities Simulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions. Parsimonious dFBA Usually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network. Cell death A simple model of cell death is implemented with each species assigned death rate. Neutral population drift The presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations. Evolutionary processes Comets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions. Computational capabilities COMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities. Graphical User Interface (GUI) In addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools. Parallelized dFBA Runs in multi-CPU systems as multi-threaded process for greater computational performance. MATLAB toolbox A toolbox in MATLAB for modifying the input files for COMETS in a programmatic way. Python toolbox A toolbox in Python for modifying the input files for COMETS in a programmatic way.","title":"Capabilities"},{"location":"capabilities/#capabilities-in-space","text":"COMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds. 2D and 3D simulation \"worlds\" In addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc. Diffusive and convective propagation of biomass in space In simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined. Substrate-dependent nutrient and biomass propagation The diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc. Boundary conditions Two types of boundary conditions are implemented. Fixed value and fixed source or sink rate.","title":"Capabilities in space"},{"location":"capabilities/#biological-capabilities","text":"COMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions. Lag-phases in microbial growth Lag-phases are modelled as simulated growth activation of the colonies. Continuous (chemostat) and batch growth modes In chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency. Simulation of multispecies communities Simulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions. Parsimonious dFBA Usually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network. Cell death A simple model of cell death is implemented with each species assigned death rate. Neutral population drift The presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations. Evolutionary processes Comets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions.","title":"Biological capabilities"},{"location":"capabilities/#computational-capabilities","text":"COMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities. Graphical User Interface (GUI) In addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools. Parallelized dFBA Runs in multi-CPU systems as multi-threaded process for greater computational performance. MATLAB toolbox A toolbox in MATLAB for modifying the input files for COMETS in a programmatic way. Python toolbox A toolbox in Python for modifying the input files for COMETS in a programmatic way.","title":"Computational capabilities"},{"location":"chemostat/","text":"Here, we will simulate an experiment in which two species compete for a single resource in a chemostat setting, in which resources are continuously replenished.","title":"Chemostat"},{"location":"creating-layout/","text":"In MATLAB-COMETS Toolbox First, you must instantiate a layout as a member of the CometsLayout class. createLayout() : creates an empty CometsLayout object using default parameters createLayout(CometsParams) : creates an empty CometsLayout object which uses the given set of parameters createLayout(cobraModel) or createLayout([cobraModels]) : creates a CometsLayout containing the given model or models. Once your layout is completed and modified to your liking, you can generate the layout file and the related files (namely the model files and script file) by using the writeCometsLayout (CometsLayout,directory) function. Example Code: layout = createCometsLayout(); layout = addModel(layout,cobramodel); writeCometsLayout(layout,pwd);","title":"Creating layout"},{"location":"creating-layout/#in-matlab-comets-toolbox","text":"First, you must instantiate a layout as a member of the CometsLayout class. createLayout() : creates an empty CometsLayout object using default parameters createLayout(CometsParams) : creates an empty CometsLayout object which uses the given set of parameters createLayout(cobraModel) or createLayout([cobraModels]) : creates a CometsLayout containing the given model or models. Once your layout is completed and modified to your liking, you can generate the layout file and the related files (namely the model files and script file) by using the writeCometsLayout (CometsLayout,directory) function. Example Code: layout = createCometsLayout(); layout = addModel(layout,cobramodel); writeCometsLayout(layout,pwd);","title":"In MATLAB-COMETS Toolbox"},{"location":"demographic_noise/","text":"Demographic noise and neutral drift Introduction The demographic noise is modeled as an additive stochastic term, noise term, in the spatio-temporal differential equation for the population biomass. This type of noise scales as square root of the population size. The differential equation that governs the dynamics of the biomass of each species becomes: \\begin{align} \\dot{x} & = \\sigma(y-x) \\\\ \\dot{y} & = \\rho x - y - xz \\\\ \\dot{z} & = -\\beta z + xy \\end{align} \\begin{align} \\dot{x} & = \\sigma(y-x) \\\\ \\dot{y} & = \\rho x - y - xz \\\\ \\dot{z} & = -\\beta z + xy \\end{align}","title":"Demographic noise"},{"location":"demographic_noise/#demographic-noise-and-neutral-drift","text":"","title":"Demographic noise and neutral drift"},{"location":"demographic_noise/#introduction","text":"The demographic noise is modeled as an additive stochastic term, noise term, in the spatio-temporal differential equation for the population biomass. This type of noise scales as square root of the population size. The differential equation that governs the dynamics of the biomass of each species becomes: \\begin{align} \\dot{x} & = \\sigma(y-x) \\\\ \\dot{y} & = \\rho x - y - xz \\\\ \\dot{z} & = -\\beta z + xy \\end{align} \\begin{align} \\dot{x} & = \\sigma(y-x) \\\\ \\dot{y} & = \\rho x - y - xz \\\\ \\dot{z} & = -\\beta z + xy \\end{align}","title":"Introduction"},{"location":"getting-started/","text":"Quick Start COMETS is started by running one of the the comets_win_x64 or comets_win_x32 batch files in Windows or running the ./comets script in Linux. Once it is started, a \u201cWelcome to COMETS!\u201d window shows up. Click on the \u201cLoad layout file\u201d button and navigate to the models directory. Choose a layout file to load. Once the layout is loaded the layout will show up on the screen. To change the default parameters go to the Edit tab and choose Edit Parameters. When done editing the parameters you can run a simulation by going to the Simulation tab and choosing Start Simulation. The Simulation panel will show up in the main frame. To start a simulation click on the Run/Pause Simulation button. System Requirements For best performance, COMETS requires Java JRE 1.8 or above and Gurobi 7.5 or higher. Install and Run Comets In order to run COMETS you must have Java installed on your system. Java can be downloaded and installed from here . Make sure that you have the Java bin directory in your PATH system variable . Older Versions These instructions are relevant for COMETS version 2.0.0 and up. The instruction for older versions are here . Installing on Windows COMETS for Windows is distributed as an archived .zip file. To extract it double-click on it or right-click and choose Extract All\u2026 This will create a directory COMETS_X.Y.Z_win\\comets_X.Y.Z, where X.Y.Z is the version number. The directory contains the INSTALL file. Read this file and follow the instructions to install COMETS. Installing on Mac COMETS for Linux is distributed as an archived COMETS_X.Y.Z_mac.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: \u200b $tar -zxvf COMETS_X.Y.Z_mac.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z_mac/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file. Installing on Linux COMETS for Linux is distributed as an archived COMETS_X.Y.Z.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: \u200b $tar -zxvf COMETS_X.Y.Z.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file. Running COMETS The instructions for running COMETS are in the RUNNING_COMETS file in the comets_X.Y.Z directory. The comets_X.Y.Z/layouts_and_models directory contains three examples of layouts and two models. The model_CSP_petri_dish_circles is an example of a two dimensional layout with a toy model model_CSP. The model_CSP_3D_layout is a three dimensional layout with the same toy model. The Ecoli_colony_layout is a layout for growth of an E.coli colony in two dimensions. The corresponding model is in the EC_ijo1366_model file. A detailed description of running this layout and model is here .","title":"Quick Start"},{"location":"getting-started/#quick-start","text":"COMETS is started by running one of the the comets_win_x64 or comets_win_x32 batch files in Windows or running the ./comets script in Linux. Once it is started, a \u201cWelcome to COMETS!\u201d window shows up. Click on the \u201cLoad layout file\u201d button and navigate to the models directory. Choose a layout file to load. Once the layout is loaded the layout will show up on the screen. To change the default parameters go to the Edit tab and choose Edit Parameters. When done editing the parameters you can run a simulation by going to the Simulation tab and choosing Start Simulation. The Simulation panel will show up in the main frame. To start a simulation click on the Run/Pause Simulation button.","title":"Quick Start"},{"location":"getting-started/#system-requirements","text":"For best performance, COMETS requires Java JRE 1.8 or above and Gurobi 7.5 or higher.","title":"System Requirements"},{"location":"getting-started/#install-and-run-comets","text":"In order to run COMETS you must have Java installed on your system. Java can be downloaded and installed from here . Make sure that you have the Java bin directory in your PATH system variable .","title":"Install and Run Comets"},{"location":"getting-started/#older-versions","text":"These instructions are relevant for COMETS version 2.0.0 and up. The instruction for older versions are here .","title":"Older Versions"},{"location":"getting-started/#installing-on-windows","text":"COMETS for Windows is distributed as an archived .zip file. To extract it double-click on it or right-click and choose Extract All\u2026 This will create a directory COMETS_X.Y.Z_win\\comets_X.Y.Z, where X.Y.Z is the version number. The directory contains the INSTALL file. Read this file and follow the instructions to install COMETS.","title":"Installing on Windows"},{"location":"getting-started/#installing-on-mac","text":"COMETS for Linux is distributed as an archived COMETS_X.Y.Z_mac.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: \u200b $tar -zxvf COMETS_X.Y.Z_mac.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z_mac/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file.","title":"Installing on Mac"},{"location":"getting-started/#installing-on-linux","text":"COMETS for Linux is distributed as an archived COMETS_X.Y.Z.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: \u200b $tar -zxvf COMETS_X.Y.Z.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file.","title":"Installing on Linux"},{"location":"getting-started/#running-comets","text":"The instructions for running COMETS are in the RUNNING_COMETS file in the comets_X.Y.Z directory. The comets_X.Y.Z/layouts_and_models directory contains three examples of layouts and two models. The model_CSP_petri_dish_circles is an example of a two dimensional layout with a toy model model_CSP. The model_CSP_3D_layout is a three dimensional layout with the same toy model. The Ecoli_colony_layout is a layout for growth of an E.coli colony in two dimensions. The corresponding model is in the EC_ijo1366_model file. A detailed description of running this layout and model is here .","title":"Running COMETS"},{"location":"installation/","text":"","title":"Installation"},{"location":"layout-files/","text":"Layout File Format The data blocks in this file are mostly nested within each other. The model file block encapsulates the model world and initial population blocks. The rest of the blocks are listed in the model world block. 1. Model Names This is a single line block, NOT followed by // on a line below, but at the end of the file. This must be the first line of the layout file. It is followed by the name of at least one FBA model file. model_file model_file_name1 model_file_name2 ... model_file_name_N 2. Model World This is a single line block, NOT followed by // on a line below, but after several internal data blocks. This must be the first block inside the model names block. It simply opens up the data block containing the world information. Optionally, it can be followed by the name of a file containing global media information (note that this is deprecated! Global media information should be included in the layout file under the world media block). model_world 2a. Grid Size This is required to be the first block under the model world line. It doesn\u2019t have a closing //, and only describes the width and height of the simulation grid. grid_size width height 2b. World Media The world media block contains global information of the quantity of all extracellular metabolites in the simulation. Each row in the block has two elements \u2013 the name of an extracellular metabolite (must be exactly as found in the model file) followed by the quantity in millimoles of that metabolite initialized in every block in the simulation. This block must come before the media refresh, static media, and diffusion constants blocks. world_media metab_1 quantity_1 metab_2 quantity_2 metab_3 quantity_3 . . . metab_N quantity_N // 2c. Diffusion Constants The diffusion constants block contains diffusion constant information for the extracellular metabolites in the simulation. The block begins with a global default value on the same line as the opening tag. Each row in the block, then, has two elements \u2013 the index of the metabolite in question, in the same order as in the world_media block above (starting from 0); and a value for the diffusion constant if it differs from the default. Units for these values are cm2 /s. diffusion_constants default_value index_1 diff_const_1 index_2 diff_const_2 index_3 diff_const_3 . . . // 2d. Media Refresh This block describes how much each medium component should be refreshed on each simulation cycle in any given grid space. The opening line contains global refresh values for each medium component, in the same order as presented in the world media block. Each proceeding row contains the amount of media to refresh for each grid space where there is a nonzero refresh value. That is, the only rows that should be present in this block should contain some amount of medium to be refreshed. media_refresh global_amt_1 global_amt_2 ... global_amt_N row_1 col_1 amt_1 amt_2 amt_3 ... amt_N row_2 col_2 amt_1 amt_2 amt_3 ... amt_N row_3 col_3 amt_1 amt_2 amt_3 ... amt_N . . . row_M col_M amt_1 amt_2 amt_3 ... amt_N // 2e. Static Media Like the media refresh block, this describes how the media in each space in the grid should be altered during the simulation. However, this block describes which media components should remain at a static value. That is, those media whose quantities should not change due to the effects of the simulation. This might represent a constant sink or source of a number of metabolites. This block contains pairs of data elements. Each pair starts with a binary (0 or 1) element, denoting whether or not to use that pair as a static element, and a quantity to keep that element static at. This lets one build a static media set where only a few medium elements are maintained as static, while keeping the file structure similar to the media refresh block above. For example: static_media 0 0 1 0 1 2 0 0 // Breaks into 4 pairs [0 0], [1 0], [1 2], [0 0]. Only components 2 and 3 have a 1 as their first element, so those medium components are kept static. Component 2 remains at 0, while component 3 stays at 2. Note that in this example, there are no exceptions, so this applies throughout the simulation. In general, it is done like this: static_media use_1 amt_1 use_2 amt_2 use_3 amt_3 ... use_N amt_N row_1 col_1 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_2 col_2 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_3 col_3 use_1 amt_1 use_2 amt_2 ... use_N amt_N . . . row_M col_M use_1 amt_1 use_2 amt_2 ... use_N amt_N // 2f. Barrier Coordinates Simple enough, this block describes those grid coordinates that contain barriers (i.e., no media, biomass, or diffusion can occur here). barrier row_1 col_1 row_2 col_2 row_3 col_3 . . . row_N col_N // 3. Initial Population Biomass This final block describes the initial biomass population in the layout, and has many options. The units for the biomass amounts are grams (for example, 1e-6 denotes one microgram of the corresponding species). In the default biomass layout style, there is just initial_pop left alone as the header, followed by one row for each grid space containing biomass. There must be one quantity for each metabolic model in the system. initial_pop row_1 col_1 biomass_1 biomass_2 ... biomass_N row_2 col_2 biomass_1 biomass_2 ... biomass_N row_3 col_3 biomass_1 biomass_2 ... biomass_N . . . row_M col_M biomass_1 biomass_2 ... biomass_N // The next set of options modify the initial_pop line itself, and contain no rows in the block, though the // on the line below must be present. initial_pop random N1 biomass_1 N2 biomass_2 ... // This will randomly assign Ni spaces to have biomass_i amount of biomass from model i. If biomass from different species is allowed to overlap, then that is allowed to happen in this case, but if different species is not allowed to overlap, then that rule is upheld. initial_pop random_rect X Y W H N1 biomass_1 N2 biomass_2 ... // As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. initial_pop filled biomass_1 biomass_2 ... // This will completely fill the grid with the given amount of biomass from each species. initial_pop filled_rect X Y W H biomass_1 biomass_2. .. // This will completely fill the rectangle (see above) with biomass from each species. initial_pop square N1 biomass_1 N2 biomass_2 ... // This will fill squares with radius Ni at the center of the grid with biomass_i from species i. 4. Parameters This block contains parameters initially loaded with the file. A table of accepted parameters and their default values is provided at the end of this document. Here\u2019s the structure of the block: parameters param_1 = value_1 param_2 = value_2 . . . param_N = value_N // Sample Layout File model_file ec_iAF1260.cmf model_world grid_size 100 100 world_media M1 0 M2 100 M3 100 M4 0 M5 50 // diffusion_constants 1e-6 0 1e-5 1 5e-6 4 2.5e-6 // media_refresh 0 0 0 0 0 25 20 0 10 10 0 5 30 35 0 15 15 0 0 // static_media 1 0 0 0 0 0 0 0 0 0 10 10 0 0 1 10 1 20 0 0 0 0 // // initial_pop random 20 1 // parameters timeStep = 1 numRunThreads = 10 allowCellOverlap = false // //","title":"Layout File Format"},{"location":"layout-files/#layout-file-format","text":"The data blocks in this file are mostly nested within each other. The model file block encapsulates the model world and initial population blocks. The rest of the blocks are listed in the model world block.","title":"Layout File Format"},{"location":"layout-files/#1-model-names","text":"This is a single line block, NOT followed by // on a line below, but at the end of the file. This must be the first line of the layout file. It is followed by the name of at least one FBA model file. model_file model_file_name1 model_file_name2 ... model_file_name_N","title":"1. Model Names"},{"location":"layout-files/#2-model-world","text":"This is a single line block, NOT followed by // on a line below, but after several internal data blocks. This must be the first block inside the model names block. It simply opens up the data block containing the world information. Optionally, it can be followed by the name of a file containing global media information (note that this is deprecated! Global media information should be included in the layout file under the world media block). model_world","title":"2. Model World"},{"location":"layout-files/#2a-grid-size","text":"This is required to be the first block under the model world line. It doesn\u2019t have a closing //, and only describes the width and height of the simulation grid. grid_size width height","title":"2a. Grid Size"},{"location":"layout-files/#2b-world-media","text":"The world media block contains global information of the quantity of all extracellular metabolites in the simulation. Each row in the block has two elements \u2013 the name of an extracellular metabolite (must be exactly as found in the model file) followed by the quantity in millimoles of that metabolite initialized in every block in the simulation. This block must come before the media refresh, static media, and diffusion constants blocks. world_media metab_1 quantity_1 metab_2 quantity_2 metab_3 quantity_3 . . . metab_N quantity_N //","title":"2b. World Media"},{"location":"layout-files/#2c-diffusion-constants","text":"The diffusion constants block contains diffusion constant information for the extracellular metabolites in the simulation. The block begins with a global default value on the same line as the opening tag. Each row in the block, then, has two elements \u2013 the index of the metabolite in question, in the same order as in the world_media block above (starting from 0); and a value for the diffusion constant if it differs from the default. Units for these values are cm2 /s. diffusion_constants default_value index_1 diff_const_1 index_2 diff_const_2 index_3 diff_const_3 . . . //","title":"2c. Diffusion Constants"},{"location":"layout-files/#2d-media-refresh","text":"This block describes how much each medium component should be refreshed on each simulation cycle in any given grid space. The opening line contains global refresh values for each medium component, in the same order as presented in the world media block. Each proceeding row contains the amount of media to refresh for each grid space where there is a nonzero refresh value. That is, the only rows that should be present in this block should contain some amount of medium to be refreshed. media_refresh global_amt_1 global_amt_2 ... global_amt_N row_1 col_1 amt_1 amt_2 amt_3 ... amt_N row_2 col_2 amt_1 amt_2 amt_3 ... amt_N row_3 col_3 amt_1 amt_2 amt_3 ... amt_N . . . row_M col_M amt_1 amt_2 amt_3 ... amt_N //","title":"2d. Media Refresh"},{"location":"layout-files/#2e-static-media","text":"Like the media refresh block, this describes how the media in each space in the grid should be altered during the simulation. However, this block describes which media components should remain at a static value. That is, those media whose quantities should not change due to the effects of the simulation. This might represent a constant sink or source of a number of metabolites. This block contains pairs of data elements. Each pair starts with a binary (0 or 1) element, denoting whether or not to use that pair as a static element, and a quantity to keep that element static at. This lets one build a static media set where only a few medium elements are maintained as static, while keeping the file structure similar to the media refresh block above. For example: static_media 0 0 1 0 1 2 0 0 // Breaks into 4 pairs [0 0], [1 0], [1 2], [0 0]. Only components 2 and 3 have a 1 as their first element, so those medium components are kept static. Component 2 remains at 0, while component 3 stays at 2. Note that in this example, there are no exceptions, so this applies throughout the simulation. In general, it is done like this: static_media use_1 amt_1 use_2 amt_2 use_3 amt_3 ... use_N amt_N row_1 col_1 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_2 col_2 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_3 col_3 use_1 amt_1 use_2 amt_2 ... use_N amt_N . . . row_M col_M use_1 amt_1 use_2 amt_2 ... use_N amt_N //","title":"2e. Static Media"},{"location":"layout-files/#2f-barrier-coordinates","text":"Simple enough, this block describes those grid coordinates that contain barriers (i.e., no media, biomass, or diffusion can occur here). barrier row_1 col_1 row_2 col_2 row_3 col_3 . . . row_N col_N //","title":"2f. Barrier Coordinates"},{"location":"layout-files/#3-initial-population-biomass","text":"This final block describes the initial biomass population in the layout, and has many options. The units for the biomass amounts are grams (for example, 1e-6 denotes one microgram of the corresponding species). In the default biomass layout style, there is just initial_pop left alone as the header, followed by one row for each grid space containing biomass. There must be one quantity for each metabolic model in the system. initial_pop row_1 col_1 biomass_1 biomass_2 ... biomass_N row_2 col_2 biomass_1 biomass_2 ... biomass_N row_3 col_3 biomass_1 biomass_2 ... biomass_N . . . row_M col_M biomass_1 biomass_2 ... biomass_N // The next set of options modify the initial_pop line itself, and contain no rows in the block, though the // on the line below must be present. initial_pop random N1 biomass_1 N2 biomass_2 ... // This will randomly assign Ni spaces to have biomass_i amount of biomass from model i. If biomass from different species is allowed to overlap, then that is allowed to happen in this case, but if different species is not allowed to overlap, then that rule is upheld. initial_pop random_rect X Y W H N1 biomass_1 N2 biomass_2 ... // As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. initial_pop filled biomass_1 biomass_2 ... // This will completely fill the grid with the given amount of biomass from each species. initial_pop filled_rect X Y W H biomass_1 biomass_2. .. // This will completely fill the rectangle (see above) with biomass from each species. initial_pop square N1 biomass_1 N2 biomass_2 ... // This will fill squares with radius Ni at the center of the grid with biomass_i from species i.","title":"3. Initial Population Biomass"},{"location":"layout-files/#4-parameters","text":"This block contains parameters initially loaded with the file. A table of accepted parameters and their default values is provided at the end of this document. Here\u2019s the structure of the block: parameters param_1 = value_1 param_2 = value_2 . . . param_N = value_N //","title":"4. Parameters"},{"location":"layout-files/#sample-layout-file","text":"model_file ec_iAF1260.cmf model_world grid_size 100 100 world_media M1 0 M2 100 M3 100 M4 0 M5 50 // diffusion_constants 1e-6 0 1e-5 1 5e-6 4 2.5e-6 // media_refresh 0 0 0 0 0 25 20 0 10 10 0 5 30 35 0 15 15 0 0 // static_media 1 0 0 0 0 0 0 0 0 0 10 10 0 0 1 10 1 20 0 0 0 0 // // initial_pop random 20 1 // parameters timeStep = 1 numRunThreads = 10 allowCellOverlap = false // //","title":"Sample Layout File"},{"location":"legacy-documentation/","text":"Quick Start COMETS is started by running one of the the comets_win_x64 or comets_win_x32 batch files in Windows or running the ./comets script in Linux. Once it is started, a \u201cWelcome to COMETS!\u201d window shows up. Click on the \u201cLoad layout file\u201d button and navigate to the models directory. Choose a layout file to load. Once the layout is loaded the layout will show up on the screen. To change the default parameters go to the Edit tab and choose Edit Parameters. When done editing the parameters you can run a simulation by going to the Simulation tab and choosing Start Simulation. The Simulation panel will show up in the main frame. To start a simulation click on the Run/Pause Simulation button. System Requirements For best performance, COMETS requires Java JRE 1.8 or above and Gurobi 7.5 or higher. Install and Run Comets In order to run COMETS you must have Java installed on your system. Java can be downloaded and installed from here . Make sure that you have the Java bin directory in your PATH system variable . Older Versions These instructions are relevant for COMETS version 2.0.0 and up. The instruction for older versions are here . Installing on Windows COMETS for Windows is distributed as an archived .zip file. To extract it double-click on it or right-click and choose Extract All\u2026 This will create a directory COMETS_X.Y.Z_win\\comets_X.Y.Z, where X.Y.Z is the version number. The directory contains the INSTALL file. Read this file and follow the instructions to install COMETS. Installing on Mac COMETS for Linux is distributed as an archived COMETS_X.Y.Z_mac.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: $tar -zxvf COMETS_X.Y.Z_mac.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z_mac/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file. Installing on Linux COMETS for Linux is distributed as an archived COMETS_X.Y.Z.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: $tar -zxvf COMETS_X.Y.Z.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file. Running COMETS The instructions for running COMETS are in the RUNNING_COMETS file in the comets_X.Y.Z directory. The comets_X.Y.Z/layouts_and_models directory contains three examples of layouts and two models. The model_CSP_petri_dish_circles is an example of a two dimensional layout with a toy model model_CSP. The model_CSP_3D_layout is a three dimensional layout with the same toy model. The Ecoli_colony_layout is a layout for growth of an E.coli colony in two dimensions. The corresponding model is in the EC_ijo1366_model file. A detailed description of running this layout and model is here . COMETS E. coli Simulation Example TODO: copy from https://www.bu.edu/segrelab/comets-e-coli-simulation-example/ Layout File Format The data blocks in this file are mostly nested within each other. The model file block encapsulates the model world and initial population blocks. The rest of the blocks are listed in the model world block. 1. Model Names This is a single line block, NOT followed by // on a line below, but at the end of the file. This must be the first line of the layout file. It is followed by the name of at least one FBA model file. model_file model_file_name1 model_file_name2 ... model_file_name_N 2. Model World This is a single line block, NOT followed by // on a line below, but after several internal data blocks. This must be the first block inside the model names block. It simply opens up the data block containing the world information. Optionally, it can be followed by the name of a file containing global media information (note that this is deprecated! Global media information should be included in the layout file under the world media block). model_world 2a. Grid Size This is required to be the first block under the model world line. It doesn\u2019t have a closing //, and only describes the width and height of the simulation grid. grid_size width height 2b. World Media The world media block contains global information of the quantity of all extracellular metabolites in the simulation. Each row in the block has two elements \u2013 the name of an extracellular metabolite (must be exactly as found in the model file) followed by the quantity in millimoles of that metabolite initialized in every block in the simulation. This block must come before the media refresh, static media, and diffusion constants blocks. world_media metab_1 quantity_1 metab_2 quantity_2 metab_3 quantity_3 . . . metab_N quantity_N // 2c. Diffusion Constants The diffusion constants block contains diffusion constant information for the extracellular metabolites in the simulation. The block begins with a global default value on the same line as the opening tag. Each row in the block, then, has two elements \u2013 the index of the metabolite in question, in the same order as in the world_media block above (starting from 0); and a value for the diffusion constant if it differs from the default. Units for these values are cm2 /s. diffusion_constants default_value index_1 diff_const_1 index_2 diff_const_2 index_3 diff_const_3 . . . // 2d. Media Refresh This block describes how much each medium component should be refreshed on each simulation cycle in any given grid space. The opening line contains global refresh values for each medium component, in the same order as presented in the world media block. Each proceeding row contains the amount of media to refresh for each grid space where there is a nonzero refresh value. That is, the only rows that should be present in this block should contain some amount of medium to be refreshed. media_refresh global_amt_1 global_amt_2 ... global_amt_N row_1 col_1 amt_1 amt_2 amt_3 ... amt_N row_2 col_2 amt_1 amt_2 amt_3 ... amt_N row_3 col_3 amt_1 amt_2 amt_3 ... amt_N . . . row_M col_M amt_1 amt_2 amt_3 ... amt_N // 2e. Static Media Like the media refresh block, this describes how the media in each space in the grid should be altered during the simulation. However, this block describes which media components should remain at a static value. That is, those media whose quantities should not change due to the effects of the simulation. This might represent a constant sink or source of a number of metabolites. This block contains pairs of data elements. Each pair starts with a binary (0 or 1) element, denoting whether or not to use that pair as a static element, and a quantity to keep that element static at. This lets one build a static media set where only a few medium elements are maintained as static, while keeping the file structure similar to the media refresh block above. For example: static_media 0 0 1 0 1 2 0 0 // Breaks into 4 pairs [0 0], [1 0], [1 2], [0 0]. Only components 2 and 3 have a 1 as their first element, so those medium components are kept static. Component 2 remains at 0, while component 3 stays at 2. Note that in this example, there are no exceptions, so this applies throughout the simulation. In general, it is done like this: static_media use_1 amt_1 use_2 amt_2 use_3 amt_3 ... use_N amt_N row_1 col_1 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_2 col_2 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_3 col_3 use_1 amt_1 use_2 amt_2 ... use_N amt_N . . . row_M col_M use_1 amt_1 use_2 amt_2 ... use_N amt_N // 2f. Barrier Coordinates Simple enough, this block describes those grid coordinates that contain barriers (i.e., no media, biomass, or diffusion can occur here). barrier row_1 col_1 row_2 col_2 row_3 col_3 . . . row_N col_N // 3. Initial Population Biomass This final block describes the initial biomass population in the layout, and has many options. The units for the biomass amounts are grams (for example, 1e-6 denotes one microgram of the corresponding species). In the default biomass layout style, there is just initial_pop left alone as the header, followed by one row for each grid space containing biomass. There must be one quantity for each metabolic model in the system. initial_pop row_1 col_1 biomass_1 biomass_2 ... biomass_N row_2 col_2 biomass_1 biomass_2 ... biomass_N row_3 col_3 biomass_1 biomass_2 ... biomass_N . . . row_M col_M biomass_1 biomass_2 ... biomass_N // The next set of options modify the initial_pop line itself, and contain no rows in the block, though the // on the line below must be present. initial_pop random N1 biomass_1 N2 biomass_2 ... // This will randomly assign Ni spaces to have biomass_i amount of biomass from model i. If biomass from different species is allowed to overlap, then that is allowed to happen in this case, but if different species is not allowed to overlap, then that rule is upheld. initial_pop random_rect X Y W H N1 biomass_1 N2 biomass_2 ... // As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. initial_pop filled biomass_1 biomass_2 ... // This will completely fill the grid with the given amount of biomass from each species. initial_pop filled_rect X Y W H biomass_1 biomass_2 ... // This will completely fill the rectangle (see above) with biomass from each species. initial_pop square N1 biomass_1 N2 biomass_2 ... // This will fill squares with radius Ni at the center of the grid with biomass_i from species i. 4. Parameters This block contains parameters initially loaded with the file. A table of accepted parameters and their default values is provided at the end of this document. Here\u2019s the structure of the block: parameters param_1 = value_1 param_2 = value_2 . . . param_N = value_N // Sample Layout File model_file ec_iAF1260.cmf model_world \u200b grid_size 100 100 \u200b world_media \u200b M1 0 \u200b M2 100 \u200b M3 100 \u200b M4 0 \u200b M5 50 \u200b // \u200b diffusion_constants 1e-6 \u200b 0 1e-5 \u200b 1 5e-6 \u200b 4 2.5e-6 \u200b // \u200b media_refresh 0 0 0 0 0 \u200b 25 20 0 10 10 0 5 \u200b 30 35 0 15 15 0 0 \u200b // \u200b static_media 1 0 0 0 0 0 0 0 0 0 \u200b 10 10 0 0 1 10 1 20 0 0 0 0 \u200b // // initial_pop random 20 1 // parameters \u200b timeStep = 1 \u200b numRunThreads = 10 \u200b allowCellOverlap = false // // Model File Format 1. Stoichiometric Matrix A matrix element of the stoichiometric matrix Si,j denotes the number of molecules of metabolite i that participate in reaction j. All entries of this field are integer numbers. Only the non-zero matrix elements should be listed. The rest are given zero value by default. SMATRIX num_rows num_cols row_1 col_1 stoichiometry row_2 col_2 stoichiometry row_3 col_3 stoichiometry . . . // 2. Flux Bounds All flux bounds are set to the default_lower_bound and default_upper_bound values unless they are listed below. The reaction indices start with 1. BOUNDS default_lower_bound default_upper_bound rxn_1 lb ub rxn_2 lb ub rxn_3 lb ub . . . // 3a. Objective Reaction The index of the objective reaction. OBJECTIVE objective_reaction_index // 3b. Biomass Reaction Optional. The index of the reaction that should be used to calculate the rate of biomass production. If this section is not included, the system will use the Objective reaction. BIOMASS biomass_reaction_index // 4. Metabolite Names The metabolite names in the order consistent with the stoichiometric matrix. METABOLITE_NAMES name_1 name_2 name_3 . . . // 5. Reaction Names The reaction names in the order consistent with the stoichiometric matrix. REACTION_NAMES name_1 name_2 name_3 . . . // 6. Exchange Reaction Indices Exchange reaction indices as listed under reaction_names, starting with 1. EXCHANGE_REACTIONS reaction_idx_1 reaction_idx_2 reaction_idx_3 . . . // 7. Diffusion Constants Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. DIFFUSION_CONSTANTS default_value exch_1 value exch_2 value exch_3 value . . . // 8. Alpha Values Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. ALPHA_VALUES default_alpha exch_1 alpha_1 exch_2 alpha_2 exch_3 alpha_3 . . . // 9. W Values Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. W_VALUES default_W exch_1 W_1 exch_2 W_2 exch_3 W_3 . . . // 10. Km Values References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/cm3. KM_VALUES default_Km exch_1 Km_1 exch_2 Km_2 exch_3 Km_3 . . . // 11. Vmax Values References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/gCDW/hr. (gCDW being \u201cgrams cellular dry weight\u201d). VMAX_VALUES default_Vmax exch_1 Vmax_1 exch_2 Vmax_2 exch_3 Vmax_3 . . . // 12. Hill Coefficients Deprecated. This block may be included to prevent breaking legacy layouts, but is no longer used. References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. HILL_COEFFICIENTS default_Hill exch_1 Hill_1 exch_2 Hill_2 exch_3 Hill_3 . . . // 13. Objective Style Sets the objective style. The objective_style_string can be one of the values: MAXIMIZE_OBJECTIVE_FLUX MINIMIZE_OBJECTIVE_FLUX MAXIMIZE_TOTAL_FLUX MINIMIZE_TOTAL_FLUX MAX_OBJECTIVE_MAX_TOTAL MAX_OBJECTIVE_MIN_TOTAL MIN_OBJECTIVE_MAX_TOTAL MIN_OBJECTIVE_MIN_TOTAL The default is MAXIMIZE_OBJECTIVE_FLUX. If combined with GUROBI optimizer only MAXIMIZE_OBJECTIVE_FLUX and MAX_OBJECTIVE_MIN_TOTAL are functional. OBJECTIVE_STYLE objective_style_string // 14. Optimizer Only version 2.0.0 and up. Sets the optimizer. The optimizer_string can be one of the values: GUROBI GLPK The default is GUROBI. OPTIMIZER optimizer_string COMETS Parameter Descriptions General Comets Parameters The global_params.txt file contains a list of parameters that are involved in the general COMETS application. Alternatively, parameters can be included within a layout file in an optional \u201cparameters\u201d block. Note that all \u2018boolean\u2019 type parameters only allow \u201ctrue\u201d or \u201cfalse\u201d as their value (they do not accept 0 or 1). Parameter Name Type Default Description Units timeStep decimal > 0 1 time for each simulation step in hours hours deathRate decimal between 0 and 1 0.1 Fraction of biomass that degrades each hour maxSpaceBiomass decimal > 0 10 maximum allowed biomass in a space in grams grams minSpaceBiomass decimal > 0 1.00E-10 minimum allowed biomass in a space in grams (setting to a small value > 0 might avoid some numerical errors) grams spaceWidth decimal > 0 0.1 width of each space in cm cm spaceVolume (deprecated) decimal > 0 1 volume of each space in mL. This input is ignored in the latest versions of COMETS, where volume is the cube of the spaceWidth mL allowCellOverlap boolean FALSE if true, allows different species to occupy the same space colorRelative boolean TRUE if true, colors each space relative to the space with the highest value. showCycleTime boolean TRUE if true, shows the time it took to finish the fba cycle in the output showCycleCount boolean TRUE if true, shows the current cycle number in the output pauseOnStep boolean true (false if running as a script) if true, pauses the simulation after completing a step displayLayer int 0..num media 0 sets the current medium component (or biomass) to be displayed pixelScale int > 0 4 the number of pixels to render for each space gridRows int > 0 100 the number of rows in the simulation gridCols int > 0 100 the number of columns in the simulation maxCycles int > 0 or -1 -1 (infinite) the maximum number of simulation steps to run. If set to -1, this is unlimited. simulateActivation boolean FALSE if true, the models are activated with the set activationRate activateRate decimal > 0 0.001 the value of activation rate toroidalWorld boolean FALSE If true, edge cells are considered adjacent to the cell on the opposite edge randomSeed long 0 Seed value for the semirandom number generator Slideshow specific parameters Parameter Name Type Default Description saveSlideshow boolean FALSE if true, saves a graphics slideshow to a series of files. See also slideshowName. slideshowColorRelative boolean TRUE as colorRelative above, applied to the slideshow slideshowRate int > 0 1 the number of steps between taking a slideshow picture slideshowLayer int 0..num media 0 the layer to take a snapshot of for each slideshow step, in order of media from 0 to N-1 (for N media components). If this is set to N, a snapshot of the biomass is taken. slideshowExt String png the file extension for slideshow pictures. Currently, only \u201cpng\u201d \u201cbmp\u201d and \u201cjpg\u201d are supported, and \u201cpng\u201d is probably the best. Constructing GIFs and Movies Slideshows can be converted from a bunch of image files (such as pngs) to a gif or movie file using the convert command. e.g. convert *.png slideshow.gif find more details on the convert command here: http://www.astro.umd.edu/~dcr/Courses/ASTR615/intro_viz/node7.html and here: http://www.ma.utexas.edu/cgi-bin/man-cgi?convert+1 This command requires the program \u201cImageMagick\u201d ( http://www.imagemagick.org/script/index.php ) which is installed by default on most linux distributions. FBA Modeling Parameters The package_params.txt file contains a list of parameters that are particular to the FBA functions of COMETS. If other packages are created, they will probably use different sets of parameters. FBA parameters Parameter Name Type Default Description Units exchangeStyle String:{Standard FBA | Monod Style | Pseudo-Monod Style} Standard FBA Sets the method used for calculating maximum exchange rates for all extracellular metabolites. Only one of the three strings is an allowed value biomassMotionStyle String:{\u201cDiffusion 2D(Crank-Nicolson)\u201d, \u201cDiffusion 2D(Eight Point)\u201d, \u201cDiffusion 3D\u201d, \u201cConvection 2D\u201d, \u201cConvection 3D\u201d } \u201cDiffusion 2D(Crank-Nicolson)\u201d Sets the method used for diffusing biomass. Only one of the indicated strings is an allowed value numDiffPerStep int > 0 10 Number of partial diffusions to do for each time step. Instead of doing one big jump for a time step, this gives the option of breaking the time step into smaller pieces to do a smoother diffusion calculation. growthDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for growth in cm^2/s cm2/s flowDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for non-growth diffusion in cm^2/s cm2/s defaultVmax decimal > 0 10 The default Vmax value for Monod-style exchange mmol/gCDW/hr defaultKm decimal > 0 5 The default Km value for Monod-style exchange mmol/cm3 defaultHill decimal > 0 2 The default Hill coefficient for Monod-style exchange defaultAlpha decimal > 0 1 The default Alpha coefficient (slope) for the Pseudo-Monod style exchange defaultW decimal > 0 10 The default W coefficient (plateau) for the Pseudo-Monod style exchange defaultDiffConst decimal > 0 1.00E-05 The default diffusion constant for extracellular metabolites randomOrder boolean TRUE Should the order that models are processed at each timestep be randomized? If false, they are always run in the order presented in the first line of the layout file. numRunThreads Int > 0 1 Allow multithreaded computation numExRxnSubsteps Int > 0 5 Number times a timestep can be cut in half so an extracellular reaction can be calculated with increased accuracy when reactant concentrations approach 0 Log file parameters Parameter Name Type Default Description useLogNameTimeStamp boolean TRUE If true, appends a time stamp to every log file name writeFluxLog boolean FALSE If true, writes fluxes out to a log file fluxLogName String \u201cflux_log.txt\u201d The name of the flux log file fluxLogRate int > 0 1 How often (number of simulation steps) to write to the flux file. A value of 1 will cause writing after every step. writeMediaLog boolean FALSE if true, writes media information to a log file mediaLogName String media_log.txt The name of the media log file mediaLogRate int > 0 1 How often to write to the media file writeBiomassLog boolean FALSE if true, writes biomass information to a log file biomassLogName String biomass_log.txt The name of the biomass log file biomassLogRate int > 0 1 How often to write to the biomass file writeTotalBiomassLog boolean FALSE if true, writes a summation of all biomass information to a log file totalBiomassLogName String total_biomass_log.txt The name of the total biomass log file totalBiomassLogRate int > 0 1 How often to write to the total biomass log file","title":"Quick Start"},{"location":"legacy-documentation/#quick-start","text":"COMETS is started by running one of the the comets_win_x64 or comets_win_x32 batch files in Windows or running the ./comets script in Linux. Once it is started, a \u201cWelcome to COMETS!\u201d window shows up. Click on the \u201cLoad layout file\u201d button and navigate to the models directory. Choose a layout file to load. Once the layout is loaded the layout will show up on the screen. To change the default parameters go to the Edit tab and choose Edit Parameters. When done editing the parameters you can run a simulation by going to the Simulation tab and choosing Start Simulation. The Simulation panel will show up in the main frame. To start a simulation click on the Run/Pause Simulation button.","title":"Quick Start"},{"location":"legacy-documentation/#system-requirements","text":"For best performance, COMETS requires Java JRE 1.8 or above and Gurobi 7.5 or higher.","title":"System Requirements"},{"location":"legacy-documentation/#install-and-run-comets","text":"In order to run COMETS you must have Java installed on your system. Java can be downloaded and installed from here . Make sure that you have the Java bin directory in your PATH system variable .","title":"Install and Run Comets"},{"location":"legacy-documentation/#older-versions","text":"These instructions are relevant for COMETS version 2.0.0 and up. The instruction for older versions are here .","title":"Older Versions"},{"location":"legacy-documentation/#installing-on-windows","text":"COMETS for Windows is distributed as an archived .zip file. To extract it double-click on it or right-click and choose Extract All\u2026 This will create a directory COMETS_X.Y.Z_win\\comets_X.Y.Z, where X.Y.Z is the version number. The directory contains the INSTALL file. Read this file and follow the instructions to install COMETS.","title":"Installing on Windows"},{"location":"legacy-documentation/#installing-on-mac","text":"COMETS for Linux is distributed as an archived COMETS_X.Y.Z_mac.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: $tar -zxvf COMETS_X.Y.Z_mac.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z_mac/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file.","title":"Installing on Mac"},{"location":"legacy-documentation/#installing-on-linux","text":"COMETS for Linux is distributed as an archived COMETS_X.Y.Z.tar.gz file, where X.Y.Z is the version number. To extract it, run it in a terminal: $tar -zxvf COMETS_X.Y.Z.tar.gz where X.Y.Z are replaced with the version numbers. This will create a directory COMETS_X.Y.Z/comets_X.Y.Z. It contains INSTALL file. To install COMETS read the INSTALL file.","title":"Installing on Linux"},{"location":"legacy-documentation/#running-comets","text":"The instructions for running COMETS are in the RUNNING_COMETS file in the comets_X.Y.Z directory. The comets_X.Y.Z/layouts_and_models directory contains three examples of layouts and two models. The model_CSP_petri_dish_circles is an example of a two dimensional layout with a toy model model_CSP. The model_CSP_3D_layout is a three dimensional layout with the same toy model. The Ecoli_colony_layout is a layout for growth of an E.coli colony in two dimensions. The corresponding model is in the EC_ijo1366_model file. A detailed description of running this layout and model is here .","title":"Running COMETS"},{"location":"legacy-documentation/#comets-e-coli-simulation-example","text":"TODO: copy from https://www.bu.edu/segrelab/comets-e-coli-simulation-example/","title":"COMETS E. coli Simulation Example"},{"location":"legacy-documentation/#layout-file-format","text":"The data blocks in this file are mostly nested within each other. The model file block encapsulates the model world and initial population blocks. The rest of the blocks are listed in the model world block.","title":"Layout File Format"},{"location":"legacy-documentation/#1-model-names","text":"This is a single line block, NOT followed by // on a line below, but at the end of the file. This must be the first line of the layout file. It is followed by the name of at least one FBA model file. model_file model_file_name1 model_file_name2 ... model_file_name_N","title":"1. Model Names"},{"location":"legacy-documentation/#2-model-world","text":"This is a single line block, NOT followed by // on a line below, but after several internal data blocks. This must be the first block inside the model names block. It simply opens up the data block containing the world information. Optionally, it can be followed by the name of a file containing global media information (note that this is deprecated! Global media information should be included in the layout file under the world media block). model_world","title":"2. Model World"},{"location":"legacy-documentation/#2a-grid-size","text":"This is required to be the first block under the model world line. It doesn\u2019t have a closing //, and only describes the width and height of the simulation grid. grid_size width height","title":"2a. Grid Size"},{"location":"legacy-documentation/#2b-world-media","text":"The world media block contains global information of the quantity of all extracellular metabolites in the simulation. Each row in the block has two elements \u2013 the name of an extracellular metabolite (must be exactly as found in the model file) followed by the quantity in millimoles of that metabolite initialized in every block in the simulation. This block must come before the media refresh, static media, and diffusion constants blocks. world_media metab_1 quantity_1 metab_2 quantity_2 metab_3 quantity_3 . . . metab_N quantity_N //","title":"2b. World Media"},{"location":"legacy-documentation/#2c-diffusion-constants","text":"The diffusion constants block contains diffusion constant information for the extracellular metabolites in the simulation. The block begins with a global default value on the same line as the opening tag. Each row in the block, then, has two elements \u2013 the index of the metabolite in question, in the same order as in the world_media block above (starting from 0); and a value for the diffusion constant if it differs from the default. Units for these values are cm2 /s. diffusion_constants default_value index_1 diff_const_1 index_2 diff_const_2 index_3 diff_const_3 . . . //","title":"2c. Diffusion Constants"},{"location":"legacy-documentation/#2d-media-refresh","text":"This block describes how much each medium component should be refreshed on each simulation cycle in any given grid space. The opening line contains global refresh values for each medium component, in the same order as presented in the world media block. Each proceeding row contains the amount of media to refresh for each grid space where there is a nonzero refresh value. That is, the only rows that should be present in this block should contain some amount of medium to be refreshed. media_refresh global_amt_1 global_amt_2 ... global_amt_N row_1 col_1 amt_1 amt_2 amt_3 ... amt_N row_2 col_2 amt_1 amt_2 amt_3 ... amt_N row_3 col_3 amt_1 amt_2 amt_3 ... amt_N . . . row_M col_M amt_1 amt_2 amt_3 ... amt_N //","title":"2d. Media Refresh"},{"location":"legacy-documentation/#2e-static-media","text":"Like the media refresh block, this describes how the media in each space in the grid should be altered during the simulation. However, this block describes which media components should remain at a static value. That is, those media whose quantities should not change due to the effects of the simulation. This might represent a constant sink or source of a number of metabolites. This block contains pairs of data elements. Each pair starts with a binary (0 or 1) element, denoting whether or not to use that pair as a static element, and a quantity to keep that element static at. This lets one build a static media set where only a few medium elements are maintained as static, while keeping the file structure similar to the media refresh block above. For example: static_media 0 0 1 0 1 2 0 0 // Breaks into 4 pairs [0 0], [1 0], [1 2], [0 0]. Only components 2 and 3 have a 1 as their first element, so those medium components are kept static. Component 2 remains at 0, while component 3 stays at 2. Note that in this example, there are no exceptions, so this applies throughout the simulation. In general, it is done like this: static_media use_1 amt_1 use_2 amt_2 use_3 amt_3 ... use_N amt_N row_1 col_1 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_2 col_2 use_1 amt_1 use_2 amt_2 ... use_N amt_N row_3 col_3 use_1 amt_1 use_2 amt_2 ... use_N amt_N . . . row_M col_M use_1 amt_1 use_2 amt_2 ... use_N amt_N //","title":"2e. Static Media"},{"location":"legacy-documentation/#2f-barrier-coordinates","text":"Simple enough, this block describes those grid coordinates that contain barriers (i.e., no media, biomass, or diffusion can occur here). barrier row_1 col_1 row_2 col_2 row_3 col_3 . . . row_N col_N //","title":"2f. Barrier Coordinates"},{"location":"legacy-documentation/#3-initial-population-biomass","text":"This final block describes the initial biomass population in the layout, and has many options. The units for the biomass amounts are grams (for example, 1e-6 denotes one microgram of the corresponding species). In the default biomass layout style, there is just initial_pop left alone as the header, followed by one row for each grid space containing biomass. There must be one quantity for each metabolic model in the system. initial_pop row_1 col_1 biomass_1 biomass_2 ... biomass_N row_2 col_2 biomass_1 biomass_2 ... biomass_N row_3 col_3 biomass_1 biomass_2 ... biomass_N . . . row_M col_M biomass_1 biomass_2 ... biomass_N // The next set of options modify the initial_pop line itself, and contain no rows in the block, though the // on the line below must be present. initial_pop random N1 biomass_1 N2 biomass_2 ... // This will randomly assign Ni spaces to have biomass_i amount of biomass from model i. If biomass from different species is allowed to overlap, then that is allowed to happen in this case, but if different species is not allowed to overlap, then that rule is upheld. initial_pop random_rect X Y W H N1 biomass_1 N2 biomass_2 ... // As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. initial_pop filled biomass_1 biomass_2 ... // This will completely fill the grid with the given amount of biomass from each species. initial_pop filled_rect X Y W H biomass_1 biomass_2 ... // This will completely fill the rectangle (see above) with biomass from each species. initial_pop square N1 biomass_1 N2 biomass_2 ... // This will fill squares with radius Ni at the center of the grid with biomass_i from species i.","title":"3. Initial Population Biomass"},{"location":"legacy-documentation/#4-parameters","text":"This block contains parameters initially loaded with the file. A table of accepted parameters and their default values is provided at the end of this document. Here\u2019s the structure of the block: parameters param_1 = value_1 param_2 = value_2 . . . param_N = value_N //","title":"4. Parameters"},{"location":"legacy-documentation/#sample-layout-file","text":"model_file ec_iAF1260.cmf model_world \u200b grid_size 100 100 \u200b world_media \u200b M1 0 \u200b M2 100 \u200b M3 100 \u200b M4 0 \u200b M5 50 \u200b // \u200b diffusion_constants 1e-6 \u200b 0 1e-5 \u200b 1 5e-6 \u200b 4 2.5e-6 \u200b // \u200b media_refresh 0 0 0 0 0 \u200b 25 20 0 10 10 0 5 \u200b 30 35 0 15 15 0 0 \u200b // \u200b static_media 1 0 0 0 0 0 0 0 0 0 \u200b 10 10 0 0 1 10 1 20 0 0 0 0 \u200b // // initial_pop random 20 1 // parameters \u200b timeStep = 1 \u200b numRunThreads = 10 \u200b allowCellOverlap = false // //","title":"Sample Layout File"},{"location":"legacy-documentation/#model-file-format","text":"","title":"Model File Format"},{"location":"legacy-documentation/#1-stoichiometric-matrix","text":"A matrix element of the stoichiometric matrix Si,j denotes the number of molecules of metabolite i that participate in reaction j. All entries of this field are integer numbers. Only the non-zero matrix elements should be listed. The rest are given zero value by default. SMATRIX num_rows num_cols row_1 col_1 stoichiometry row_2 col_2 stoichiometry row_3 col_3 stoichiometry . . . //","title":"1. Stoichiometric Matrix"},{"location":"legacy-documentation/#2-flux-bounds","text":"All flux bounds are set to the default_lower_bound and default_upper_bound values unless they are listed below. The reaction indices start with 1. BOUNDS default_lower_bound default_upper_bound rxn_1 lb ub rxn_2 lb ub rxn_3 lb ub . . . //","title":"2. Flux Bounds"},{"location":"legacy-documentation/#3a-objective-reaction","text":"The index of the objective reaction. OBJECTIVE objective_reaction_index //","title":"3a. Objective Reaction"},{"location":"legacy-documentation/#3b-biomass-reaction","text":"Optional. The index of the reaction that should be used to calculate the rate of biomass production. If this section is not included, the system will use the Objective reaction. BIOMASS biomass_reaction_index //","title":"3b. Biomass Reaction"},{"location":"legacy-documentation/#4-metabolite-names","text":"The metabolite names in the order consistent with the stoichiometric matrix. METABOLITE_NAMES name_1 name_2 name_3 . . . //","title":"4. Metabolite Names"},{"location":"legacy-documentation/#5-reaction-names","text":"The reaction names in the order consistent with the stoichiometric matrix. REACTION_NAMES name_1 name_2 name_3 . . . //","title":"5. Reaction Names"},{"location":"legacy-documentation/#6-exchange-reaction-indices","text":"Exchange reaction indices as listed under reaction_names, starting with 1. EXCHANGE_REACTIONS reaction_idx_1 reaction_idx_2 reaction_idx_3 . . . //","title":"6. Exchange Reaction Indices"},{"location":"legacy-documentation/#7-diffusion-constants","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. DIFFUSION_CONSTANTS default_value exch_1 value exch_2 value exch_3 value . . . //","title":"7. Diffusion Constants"},{"location":"legacy-documentation/#8-alpha-values","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. ALPHA_VALUES default_alpha exch_1 alpha_1 exch_2 alpha_2 exch_3 alpha_3 . . . //","title":"8. Alpha Values"},{"location":"legacy-documentation/#9-w-values","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. W_VALUES default_W exch_1 W_1 exch_2 W_2 exch_3 W_3 . . . //","title":"9. W Values"},{"location":"legacy-documentation/#10-km-values","text":"References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/cm3. KM_VALUES default_Km exch_1 Km_1 exch_2 Km_2 exch_3 Km_3 . . . //","title":"10. Km Values"},{"location":"legacy-documentation/#11-vmax-values","text":"References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/gCDW/hr. (gCDW being \u201cgrams cellular dry weight\u201d). VMAX_VALUES default_Vmax exch_1 Vmax_1 exch_2 Vmax_2 exch_3 Vmax_3 . . . //","title":"11. Vmax Values"},{"location":"legacy-documentation/#12-hill-coefficients","text":"Deprecated. This block may be included to prevent breaking legacy layouts, but is no longer used. References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. HILL_COEFFICIENTS default_Hill exch_1 Hill_1 exch_2 Hill_2 exch_3 Hill_3 . . . //","title":"12. Hill Coefficients"},{"location":"legacy-documentation/#13-objective-style","text":"Sets the objective style. The objective_style_string can be one of the values: MAXIMIZE_OBJECTIVE_FLUX MINIMIZE_OBJECTIVE_FLUX MAXIMIZE_TOTAL_FLUX MINIMIZE_TOTAL_FLUX MAX_OBJECTIVE_MAX_TOTAL MAX_OBJECTIVE_MIN_TOTAL MIN_OBJECTIVE_MAX_TOTAL MIN_OBJECTIVE_MIN_TOTAL The default is MAXIMIZE_OBJECTIVE_FLUX. If combined with GUROBI optimizer only MAXIMIZE_OBJECTIVE_FLUX and MAX_OBJECTIVE_MIN_TOTAL are functional. OBJECTIVE_STYLE objective_style_string //","title":"13. Objective Style"},{"location":"legacy-documentation/#14-optimizer","text":"Only version 2.0.0 and up. Sets the optimizer. The optimizer_string can be one of the values: GUROBI GLPK The default is GUROBI. OPTIMIZER optimizer_string","title":"14. Optimizer"},{"location":"legacy-documentation/#comets-parameter-descriptions","text":"","title":"COMETS Parameter Descriptions"},{"location":"legacy-documentation/#general-comets-parameters","text":"The global_params.txt file contains a list of parameters that are involved in the general COMETS application. Alternatively, parameters can be included within a layout file in an optional \u201cparameters\u201d block. Note that all \u2018boolean\u2019 type parameters only allow \u201ctrue\u201d or \u201cfalse\u201d as their value (they do not accept 0 or 1). Parameter Name Type Default Description Units timeStep decimal > 0 1 time for each simulation step in hours hours deathRate decimal between 0 and 1 0.1 Fraction of biomass that degrades each hour maxSpaceBiomass decimal > 0 10 maximum allowed biomass in a space in grams grams minSpaceBiomass decimal > 0 1.00E-10 minimum allowed biomass in a space in grams (setting to a small value > 0 might avoid some numerical errors) grams spaceWidth decimal > 0 0.1 width of each space in cm cm spaceVolume (deprecated) decimal > 0 1 volume of each space in mL. This input is ignored in the latest versions of COMETS, where volume is the cube of the spaceWidth mL allowCellOverlap boolean FALSE if true, allows different species to occupy the same space colorRelative boolean TRUE if true, colors each space relative to the space with the highest value. showCycleTime boolean TRUE if true, shows the time it took to finish the fba cycle in the output showCycleCount boolean TRUE if true, shows the current cycle number in the output pauseOnStep boolean true (false if running as a script) if true, pauses the simulation after completing a step displayLayer int 0..num media 0 sets the current medium component (or biomass) to be displayed pixelScale int > 0 4 the number of pixels to render for each space gridRows int > 0 100 the number of rows in the simulation gridCols int > 0 100 the number of columns in the simulation maxCycles int > 0 or -1 -1 (infinite) the maximum number of simulation steps to run. If set to -1, this is unlimited. simulateActivation boolean FALSE if true, the models are activated with the set activationRate activateRate decimal > 0 0.001 the value of activation rate toroidalWorld boolean FALSE If true, edge cells are considered adjacent to the cell on the opposite edge randomSeed long 0 Seed value for the semirandom number generator","title":"General Comets Parameters"},{"location":"legacy-documentation/#slideshow-specific-parameters","text":"Parameter Name Type Default Description saveSlideshow boolean FALSE if true, saves a graphics slideshow to a series of files. See also slideshowName. slideshowColorRelative boolean TRUE as colorRelative above, applied to the slideshow slideshowRate int > 0 1 the number of steps between taking a slideshow picture slideshowLayer int 0..num media 0 the layer to take a snapshot of for each slideshow step, in order of media from 0 to N-1 (for N media components). If this is set to N, a snapshot of the biomass is taken. slideshowExt String png the file extension for slideshow pictures. Currently, only \u201cpng\u201d \u201cbmp\u201d and \u201cjpg\u201d are supported, and \u201cpng\u201d is probably the best.","title":"Slideshow specific parameters"},{"location":"legacy-documentation/#constructing-gifs-and-movies","text":"Slideshows can be converted from a bunch of image files (such as pngs) to a gif or movie file using the convert command. e.g. convert *.png slideshow.gif find more details on the convert command here: http://www.astro.umd.edu/~dcr/Courses/ASTR615/intro_viz/node7.html and here: http://www.ma.utexas.edu/cgi-bin/man-cgi?convert+1 This command requires the program \u201cImageMagick\u201d ( http://www.imagemagick.org/script/index.php ) which is installed by default on most linux distributions.","title":"Constructing GIFs and Movies"},{"location":"legacy-documentation/#fba-modeling-parameters","text":"The package_params.txt file contains a list of parameters that are particular to the FBA functions of COMETS. If other packages are created, they will probably use different sets of parameters.","title":"FBA Modeling Parameters"},{"location":"legacy-documentation/#fba-parameters","text":"Parameter Name Type Default Description Units exchangeStyle String:{Standard FBA | Monod Style | Pseudo-Monod Style} Standard FBA Sets the method used for calculating maximum exchange rates for all extracellular metabolites. Only one of the three strings is an allowed value biomassMotionStyle String:{\u201cDiffusion 2D(Crank-Nicolson)\u201d, \u201cDiffusion 2D(Eight Point)\u201d, \u201cDiffusion 3D\u201d, \u201cConvection 2D\u201d, \u201cConvection 3D\u201d } \u201cDiffusion 2D(Crank-Nicolson)\u201d Sets the method used for diffusing biomass. Only one of the indicated strings is an allowed value numDiffPerStep int > 0 10 Number of partial diffusions to do for each time step. Instead of doing one big jump for a time step, this gives the option of breaking the time step into smaller pieces to do a smoother diffusion calculation. growthDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for growth in cm^2/s cm2/s flowDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for non-growth diffusion in cm^2/s cm2/s defaultVmax decimal > 0 10 The default Vmax value for Monod-style exchange mmol/gCDW/hr defaultKm decimal > 0 5 The default Km value for Monod-style exchange mmol/cm3 defaultHill decimal > 0 2 The default Hill coefficient for Monod-style exchange defaultAlpha decimal > 0 1 The default Alpha coefficient (slope) for the Pseudo-Monod style exchange defaultW decimal > 0 10 The default W coefficient (plateau) for the Pseudo-Monod style exchange defaultDiffConst decimal > 0 1.00E-05 The default diffusion constant for extracellular metabolites randomOrder boolean TRUE Should the order that models are processed at each timestep be randomized? If false, they are always run in the order presented in the first line of the layout file. numRunThreads Int > 0 1 Allow multithreaded computation numExRxnSubsteps Int > 0 5 Number times a timestep can be cut in half so an extracellular reaction can be calculated with increased accuracy when reactant concentrations approach 0","title":"FBA parameters"},{"location":"legacy-documentation/#log-file-parameters","text":"Parameter Name Type Default Description useLogNameTimeStamp boolean TRUE If true, appends a time stamp to every log file name writeFluxLog boolean FALSE If true, writes fluxes out to a log file fluxLogName String \u201cflux_log.txt\u201d The name of the flux log file fluxLogRate int > 0 1 How often (number of simulation steps) to write to the flux file. A value of 1 will cause writing after every step. writeMediaLog boolean FALSE if true, writes media information to a log file mediaLogName String media_log.txt The name of the media log file mediaLogRate int > 0 1 How often to write to the media file writeBiomassLog boolean FALSE if true, writes biomass information to a log file biomassLogName String biomass_log.txt The name of the biomass log file biomassLogRate int > 0 1 How often to write to the biomass file writeTotalBiomassLog boolean FALSE if true, writes a summation of all biomass information to a log file totalBiomassLogName String total_biomass_log.txt The name of the total biomass log file totalBiomassLogRate int > 0 1 How often to write to the total biomass log file","title":"Log file parameters"},{"location":"model-files/","text":"Model File Format 1. Stoichiometric Matrix A matrix element of the stoichiometric matrix Si,j denotes the number of molecules of metabolite i that participate in reaction j. All entries of this field are integer numbers. Only the non-zero matrix elements should be listed. The rest are given zero value by default. SMATRIX num_rows num_cols row_1 col_1 stoichiometry row_2 col_2 stoichiometry row_3 col_3 stoichiometry ... // 2. Flux Bounds All flux bounds are set to the default_lower_bound and default_upper_bound values unless they are listed below. The reaction indices start with 1. BOUNDS default_lower_bound default_upper_bound rxn_1 lb ub rxn_2 lb ub rxn_3 lb ub ... // 3a. Objective Reaction The index of the objective reaction. OBJECTIVE objective_reaction_index // Multiple objectives can be given in this block. In this case, the objective fluxes are solved and fixed in the order given. By default, the flux through the objective is maximized. It can be minimized instead by placing a minus sign (-) before the objective reaction index. For example, the following block would first minimize reaction 10, then maximize reaction 15: OBJECTIVE -10 15 // 3b. Biomass Reaction Optional. The index of the reaction that should be used to calculate the rate of biomass production. If this section is not included, the system will use the Objective reaction. BIOMASS biomass_reaction_index // 4. Metabolite Names The metabolite names in the order consistent with the stoichiometric matrix. METABOLITE_NAMES name_1 name_2 name_3 ... // 5. Reaction Names The reaction names in the order consistent with the stoichiometric matrix. REACTION_NAMES name_1 name_2 name_3 ... // 6. Exchange Reaction Indices Indexes of all exchange reactions as listed under reaction_names. (Note that the first index is 1, not 0) EXCHANGE_REACTIONS reaction_idx_1 reaction_idx_2 reaction_idx_3 ... // 7. Diffusion Constants Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. DIFFUSION_CONSTANTS default_value exch_1 value exch_2 value exch_3 value ... // 8. Alpha Values Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. ALPHA_VALUES default_alpha exch_1 alpha_1 exch_2 alpha_2 exch_3 alpha_3 ... // 9. W Values Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. W_VALUES default_W exch_1 W_1 exch_2 W_2 exch_3 W_3 ... // 10. Km Values References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/cm3. KM_VALUES default_Km exch_1 Km_1 exch_2 Km_2 exch_3 Km_3 ... // 11. Vmax Values References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/gCDW/hr. (gCDW being \u201cgrams cellular dry weight\u201d). VMAX_VALUES default_Vmax exch_1 Vmax_1 exch_2 Vmax_2 exch_3 Vmax_3 ... // 12. Hill Coefficients Deprecated. This block may be included to prevent breaking legacy layouts, but is no longer used. References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. HILL_COEFFICIENTS default_Hill exch_1 Hill_1 exch_2 Hill_2 exch_3 Hill_3 ... // 13. Objective Style Sets the objective style. The objective_style_string can be one of the values: MAXIMIZE_OBJECTIVE_FLUX MINIMIZE_OBJECTIVE_FLUX MAXIMIZE_TOTAL_FLUX MINIMIZE_TOTAL_FLUX MAX_OBJECTIVE_MAX_TOTAL MAX_OBJECTIVE_MIN_TOTAL MIN_OBJECTIVE_MAX_TOTAL MIN_OBJECTIVE_MIN_TOTAL The default is MAXIMIZE_OBJECTIVE_FLUX. If combined with GUROBI optimizer only MAXIMIZE_OBJECTIVE_FLUX and MAX_OBJECTIVE_MIN_TOTAL are functional. OBJECTIVE_STYLE objective_style_string // 14. Optimizer Only version 2.0.0 and up. Sets the optimizer. The optimizer_string can be one of the values: GUROBI GLPK The default is GUROBI. OPTIMIZER optimizer_string","title":"Model File Format"},{"location":"model-files/#model-file-format","text":"","title":"Model File Format"},{"location":"model-files/#1-stoichiometric-matrix","text":"A matrix element of the stoichiometric matrix Si,j denotes the number of molecules of metabolite i that participate in reaction j. All entries of this field are integer numbers. Only the non-zero matrix elements should be listed. The rest are given zero value by default. SMATRIX num_rows num_cols row_1 col_1 stoichiometry row_2 col_2 stoichiometry row_3 col_3 stoichiometry ... //","title":"1. Stoichiometric Matrix"},{"location":"model-files/#2-flux-bounds","text":"All flux bounds are set to the default_lower_bound and default_upper_bound values unless they are listed below. The reaction indices start with 1. BOUNDS default_lower_bound default_upper_bound rxn_1 lb ub rxn_2 lb ub rxn_3 lb ub ... //","title":"2. Flux Bounds"},{"location":"model-files/#3a-objective-reaction","text":"The index of the objective reaction. OBJECTIVE objective_reaction_index // Multiple objectives can be given in this block. In this case, the objective fluxes are solved and fixed in the order given. By default, the flux through the objective is maximized. It can be minimized instead by placing a minus sign (-) before the objective reaction index. For example, the following block would first minimize reaction 10, then maximize reaction 15: OBJECTIVE -10 15 //","title":"3a. Objective Reaction"},{"location":"model-files/#3b-biomass-reaction","text":"Optional. The index of the reaction that should be used to calculate the rate of biomass production. If this section is not included, the system will use the Objective reaction. BIOMASS biomass_reaction_index //","title":"3b. Biomass Reaction"},{"location":"model-files/#4-metabolite-names","text":"The metabolite names in the order consistent with the stoichiometric matrix. METABOLITE_NAMES name_1 name_2 name_3 ... //","title":"4. Metabolite Names"},{"location":"model-files/#5-reaction-names","text":"The reaction names in the order consistent with the stoichiometric matrix. REACTION_NAMES name_1 name_2 name_3 ... //","title":"5. Reaction Names"},{"location":"model-files/#6-exchange-reaction-indices","text":"Indexes of all exchange reactions as listed under reaction_names. (Note that the first index is 1, not 0) EXCHANGE_REACTIONS reaction_idx_1 reaction_idx_2 reaction_idx_3 ... //","title":"6. Exchange Reaction Indices"},{"location":"model-files/#7-diffusion-constants","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. DIFFUSION_CONSTANTS default_value exch_1 value exch_2 value exch_3 value ... //","title":"7. Diffusion Constants"},{"location":"model-files/#8-alpha-values","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. ALPHA_VALUES default_alpha exch_1 alpha_1 exch_2 alpha_2 exch_3 alpha_3 ... //","title":"8. Alpha Values"},{"location":"model-files/#9-w-values","text":"Deprecated: This won\u2019t cause any errors if you leave it in, but it\u2019s not used by COMETS References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. W_VALUES default_W exch_1 W_1 exch_2 W_2 exch_3 W_3 ... //","title":"9. W Values"},{"location":"model-files/#10-km-values","text":"References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/cm3. KM_VALUES default_Km exch_1 Km_1 exch_2 Km_2 exch_3 Km_3 ... //","title":"10. Km Values"},{"location":"model-files/#11-vmax-values","text":"References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. The units for these values are mmol/gCDW/hr. (gCDW being \u201cgrams cellular dry weight\u201d). VMAX_VALUES default_Vmax exch_1 Vmax_1 exch_2 Vmax_2 exch_3 Vmax_3 ... //","title":"11. Vmax Values"},{"location":"model-files/#12-hill-coefficients","text":"Deprecated. This block may be included to prevent breaking legacy layouts, but is no longer used. References the indices in the exchange reaction block. That is, if there are 10 reaction indices, then there should be up to 10 lines in the block. HILL_COEFFICIENTS default_Hill exch_1 Hill_1 exch_2 Hill_2 exch_3 Hill_3 ... //","title":"12. Hill Coefficients"},{"location":"model-files/#13-objective-style","text":"Sets the objective style. The objective_style_string can be one of the values: MAXIMIZE_OBJECTIVE_FLUX MINIMIZE_OBJECTIVE_FLUX MAXIMIZE_TOTAL_FLUX MINIMIZE_TOTAL_FLUX MAX_OBJECTIVE_MAX_TOTAL MAX_OBJECTIVE_MIN_TOTAL MIN_OBJECTIVE_MAX_TOTAL MIN_OBJECTIVE_MIN_TOTAL The default is MAXIMIZE_OBJECTIVE_FLUX. If combined with GUROBI optimizer only MAXIMIZE_OBJECTIVE_FLUX and MAX_OBJECTIVE_MIN_TOTAL are functional. OBJECTIVE_STYLE objective_style_string //","title":"13. Objective Style"},{"location":"model-files/#14-optimizer","text":"Only version 2.0.0 and up. Sets the optimizer. The optimizer_string can be one of the values: GUROBI GLPK The default is GUROBI. OPTIMIZER optimizer_string","title":"14. Optimizer"},{"location":"multi_species/","text":"COMETS can simulate microbial growth with periodic dilutions in fresh media, akin to labratory experiments.","title":"Multi species"},{"location":"parameters/","text":"COMETS Parameter Descriptions General Comets Parameters The global_params.txt file contains a list of parameters that are involved in the general COMETS application. Alternatively, parameters can be included within a layout file in an optional \u201cparameters\u201d block. Note that all \u2018boolean\u2019 type parameters only allow \u201ctrue\u201d or \u201cfalse\u201d as their value (they do not accept 0 or 1). Parameter Name Type Default Description Units timeStep decimal > 0 1 time for each simulation step in hours hours deathRate decimal between 0 and 1 0.1 Fraction of biomass that degrades each hour maxSpaceBiomass decimal > 0 10 maximum allowed biomass in a space in grams grams minSpaceBiomass decimal > 0 1.00E-10 minimum allowed biomass in a space in grams (setting to a small value > 0 might avoid some numerical errors) grams spaceWidth decimal > 0 0.1 width of each space in cm cm spaceVolume (deprecated) decimal > 0 1 volume of each space in mL. This input is ignored in the latest versions of COMETS, where volume is the cube of the spaceWidth mL allowCellOverlap boolean FALSE if true, allows different species to occupy the same space colorRelative boolean TRUE if true, colors each space relative to the space with the highest value. showCycleTime boolean TRUE if true, shows the time it took to finish the fba cycle in the output showCycleCount boolean TRUE if true, shows the current cycle number in the output pauseOnStep boolean true (false if running as a script) if true, pauses the simulation after completing a step displayLayer int 0..num media 0 sets the current medium component (or biomass) to be displayed pixelScale int > 0 4 the number of pixels to render for each space gridRows int > 0 100 the number of rows in the simulation gridCols int > 0 100 the number of columns in the simulation maxCycles int > 0 or -1 -1 (infinite) the maximum number of simulation steps to run. If set to -1, this is unlimited. simulateActivation boolean FALSE if true, the models are activated with the set activationRate activateRate decimal > 0 0.001 the value of activation rate toroidalWorld boolean FALSE If true, edge cells are considered adjacent to the cell on the opposite edge randomSeed long 0 Seed value for the semirandom number generator Slideshow specific parameters Parameter Name Type Default Description saveSlideshow boolean FALSE if true, saves a graphics slideshow to a series of files. See also slideshowName. slideshowColorRelative boolean TRUE as colorRelative above, applied to the slideshow slideshowRate int > 0 1 the number of steps between taking a slideshow picture slideshowLayer int 0..num media 0 the layer to take a snapshot of for each slideshow step, in order of media from 0 to N-1 (for N media components). If this is set to N, a snapshot of the biomass is taken. slideshowExt String png the file extension for slideshow pictures. Currently, only \u201cpng\u201d \u201cbmp\u201d and \u201cjpg\u201d are supported, and \u201cpng\u201d is probably the best. Constructing GIFs and Movies Slideshows can be converted from a bunch of image files (such as pngs) to a gif or movie file using the convert command. e.g. convert *.png slideshow.gif find more details on the convert command here: http://www.astro.umd.edu/~dcr/Courses/ASTR615/intro_viz/node7.html and here: http://www.ma.utexas.edu/cgi-bin/man-cgi?convert+1 This command requires the program \u201cImageMagick\u201d ( http://www.imagemagick.org/script/index.php ) which is installed by default on most linux distributions. FBA Modeling Parameters The package_params.txt file contains a list of parameters that are particular to the FBA functions of COMETS. If other packages are created, they will probably use different sets of parameters. FBA parameters Parameter Name Type Default Description Units exchangeStyle String:{Standard FBA | Monod Style | Pseudo-Monod Style} Standard FBA Sets the method used for calculating maximum exchange rates for all extracellular metabolites. Only one of the three strings is an allowed value biomassMotionStyle String:{\u201cDiffusion 2D(Crank-Nicolson)\u201d, \u201cDiffusion 2D(Eight Point)\u201d, \u201cDiffusion 3D\u201d, \u201cConvection 2D\u201d, \u201cConvection 3D\u201d } \u201cDiffusion 2D(Crank-Nicolson)\u201d Sets the method used for diffusing biomass. Only one of the indicated strings is an allowed value numDiffPerStep int > 0 10 Number of partial diffusions to do for each time step. Instead of doing one big jump for a time step, this gives the option of breaking the time step into smaller pieces to do a smoother diffusion calculation. growthDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for growth in cm^2/s cm2/s flowDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for non-growth diffusion in cm^2/s cm2/s defaultVmax decimal > 0 10 The default Vmax value for Monod-style exchange mmol/gCDW/hr defaultKm decimal > 0 5 The default Km value for Monod-style exchange mmol/cm3 defaultHill decimal > 0 2 The default Hill coefficient for Monod-style exchange defaultAlpha decimal > 0 1 The default Alpha coefficient (slope) for the Pseudo-Monod style exchange defaultW decimal > 0 10 The default W coefficient (plateau) for the Pseudo-Monod style exchange defaultDiffConst decimal > 0 1.00E-05 The default diffusion constant for extracellular metabolites randomOrder boolean TRUE Should the order that models are processed at each timestep be randomized? If false, they are always run in the order presented in the first line of the layout file. numRunThreads Int > 0 1 Allow multithreaded computation numExRxnSubsteps Int > 0 5 Number times a timestep can be cut in half so an extracellular reaction can be calculated with increased accuracy when reactant concentrations approach 0 Log file parameters Parameter Name Type Default Description useLogNameTimeStamp boolean TRUE If true, appends a time stamp to every log file name writeFluxLog boolean FALSE If true, writes fluxes out to a log file fluxLogName String \u201cflux_log.txt\u201d The name of the flux log file fluxLogRate int > 0 1 How often (number of simulation steps) to write to the flux file. A value of 1 will cause writing after every step. writeMediaLog boolean FALSE if true, writes media information to a log file mediaLogName String media_log.txt The name of the media log file mediaLogRate int > 0 1 How often to write to the media file writeBiomassLog boolean FALSE if true, writes biomass information to a log file biomassLogName String biomass_log.txt The name of the biomass log file biomassLogRate int > 0 1 How often to write to the biomass file writeTotalBiomassLog boolean FALSE if true, writes a summation of all biomass information to a log file totalBiomassLogName String total_biomass_log.txt The name of the total biomass log file totalBiomassLogRate int > 0 1 How often to write to the total biomass log file","title":"COMETS Parameter Descriptions"},{"location":"parameters/#comets-parameter-descriptions","text":"","title":"COMETS Parameter Descriptions"},{"location":"parameters/#general-comets-parameters","text":"The global_params.txt file contains a list of parameters that are involved in the general COMETS application. Alternatively, parameters can be included within a layout file in an optional \u201cparameters\u201d block. Note that all \u2018boolean\u2019 type parameters only allow \u201ctrue\u201d or \u201cfalse\u201d as their value (they do not accept 0 or 1). Parameter Name Type Default Description Units timeStep decimal > 0 1 time for each simulation step in hours hours deathRate decimal between 0 and 1 0.1 Fraction of biomass that degrades each hour maxSpaceBiomass decimal > 0 10 maximum allowed biomass in a space in grams grams minSpaceBiomass decimal > 0 1.00E-10 minimum allowed biomass in a space in grams (setting to a small value > 0 might avoid some numerical errors) grams spaceWidth decimal > 0 0.1 width of each space in cm cm spaceVolume (deprecated) decimal > 0 1 volume of each space in mL. This input is ignored in the latest versions of COMETS, where volume is the cube of the spaceWidth mL allowCellOverlap boolean FALSE if true, allows different species to occupy the same space colorRelative boolean TRUE if true, colors each space relative to the space with the highest value. showCycleTime boolean TRUE if true, shows the time it took to finish the fba cycle in the output showCycleCount boolean TRUE if true, shows the current cycle number in the output pauseOnStep boolean true (false if running as a script) if true, pauses the simulation after completing a step displayLayer int 0..num media 0 sets the current medium component (or biomass) to be displayed pixelScale int > 0 4 the number of pixels to render for each space gridRows int > 0 100 the number of rows in the simulation gridCols int > 0 100 the number of columns in the simulation maxCycles int > 0 or -1 -1 (infinite) the maximum number of simulation steps to run. If set to -1, this is unlimited. simulateActivation boolean FALSE if true, the models are activated with the set activationRate activateRate decimal > 0 0.001 the value of activation rate toroidalWorld boolean FALSE If true, edge cells are considered adjacent to the cell on the opposite edge randomSeed long 0 Seed value for the semirandom number generator","title":"General Comets Parameters"},{"location":"parameters/#slideshow-specific-parameters","text":"Parameter Name Type Default Description saveSlideshow boolean FALSE if true, saves a graphics slideshow to a series of files. See also slideshowName. slideshowColorRelative boolean TRUE as colorRelative above, applied to the slideshow slideshowRate int > 0 1 the number of steps between taking a slideshow picture slideshowLayer int 0..num media 0 the layer to take a snapshot of for each slideshow step, in order of media from 0 to N-1 (for N media components). If this is set to N, a snapshot of the biomass is taken. slideshowExt String png the file extension for slideshow pictures. Currently, only \u201cpng\u201d \u201cbmp\u201d and \u201cjpg\u201d are supported, and \u201cpng\u201d is probably the best.","title":"Slideshow specific parameters"},{"location":"parameters/#constructing-gifs-and-movies","text":"Slideshows can be converted from a bunch of image files (such as pngs) to a gif or movie file using the convert command. e.g. convert *.png slideshow.gif find more details on the convert command here: http://www.astro.umd.edu/~dcr/Courses/ASTR615/intro_viz/node7.html and here: http://www.ma.utexas.edu/cgi-bin/man-cgi?convert+1 This command requires the program \u201cImageMagick\u201d ( http://www.imagemagick.org/script/index.php ) which is installed by default on most linux distributions.","title":"Constructing GIFs and Movies"},{"location":"parameters/#fba-modeling-parameters","text":"The package_params.txt file contains a list of parameters that are particular to the FBA functions of COMETS. If other packages are created, they will probably use different sets of parameters.","title":"FBA Modeling Parameters"},{"location":"parameters/#fba-parameters","text":"Parameter Name Type Default Description Units exchangeStyle String:{Standard FBA | Monod Style | Pseudo-Monod Style} Standard FBA Sets the method used for calculating maximum exchange rates for all extracellular metabolites. Only one of the three strings is an allowed value biomassMotionStyle String:{\u201cDiffusion 2D(Crank-Nicolson)\u201d, \u201cDiffusion 2D(Eight Point)\u201d, \u201cDiffusion 3D\u201d, \u201cConvection 2D\u201d, \u201cConvection 3D\u201d } \u201cDiffusion 2D(Crank-Nicolson)\u201d Sets the method used for diffusing biomass. Only one of the indicated strings is an allowed value numDiffPerStep int > 0 10 Number of partial diffusions to do for each time step. Instead of doing one big jump for a time step, this gives the option of breaking the time step into smaller pieces to do a smoother diffusion calculation. growthDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for growth in cm^2/s cm2/s flowDiffRate decimal > 0 1.00E-07 The default biomass diffusion constant for non-growth diffusion in cm^2/s cm2/s defaultVmax decimal > 0 10 The default Vmax value for Monod-style exchange mmol/gCDW/hr defaultKm decimal > 0 5 The default Km value for Monod-style exchange mmol/cm3 defaultHill decimal > 0 2 The default Hill coefficient for Monod-style exchange defaultAlpha decimal > 0 1 The default Alpha coefficient (slope) for the Pseudo-Monod style exchange defaultW decimal > 0 10 The default W coefficient (plateau) for the Pseudo-Monod style exchange defaultDiffConst decimal > 0 1.00E-05 The default diffusion constant for extracellular metabolites randomOrder boolean TRUE Should the order that models are processed at each timestep be randomized? If false, they are always run in the order presented in the first line of the layout file. numRunThreads Int > 0 1 Allow multithreaded computation numExRxnSubsteps Int > 0 5 Number times a timestep can be cut in half so an extracellular reaction can be calculated with increased accuracy when reactant concentrations approach 0","title":"FBA parameters"},{"location":"parameters/#log-file-parameters","text":"Parameter Name Type Default Description useLogNameTimeStamp boolean TRUE If true, appends a time stamp to every log file name writeFluxLog boolean FALSE If true, writes fluxes out to a log file fluxLogName String \u201cflux_log.txt\u201d The name of the flux log file fluxLogRate int > 0 1 How often (number of simulation steps) to write to the flux file. A value of 1 will cause writing after every step. writeMediaLog boolean FALSE if true, writes media information to a log file mediaLogName String media_log.txt The name of the media log file mediaLogRate int > 0 1 How often to write to the media file writeBiomassLog boolean FALSE if true, writes biomass information to a log file biomassLogName String biomass_log.txt The name of the biomass log file biomassLogRate int > 0 1 How often to write to the biomass file writeTotalBiomassLog boolean FALSE if true, writes a summation of all biomass information to a log file totalBiomassLogName String total_biomass_log.txt The name of the total biomass log file totalBiomassLogRate int > 0 1 How often to write to the total biomass log file","title":"Log file parameters"},{"location":"petri/","text":"One of the main features of COMETS is the ability to perform simulations where microbes grow in a spatially structured environment. One of the simplest demonstrations of this is simulating the growth of colonies on a 2D surface, for example an agar plate Changing biomass propagation: swimming and swarming Simulations in 3D environments","title":"Petri"},{"location":"petri/#changing-biomass-propagation-swimming-and-swarming","text":"","title":"Changing biomass propagation: swimming and swarming"},{"location":"petri/#simulations-in-3d-environments","text":"","title":"Simulations in 3D environments"},{"location":"single_species/","text":"We start with the simplest possible COMETS simulation, with only one species in a well-mixed environment (i.e. no spatial structure), and only one finite resource. Specifically, we will simulate growth of Escherichia coli in glucose minimal media during a 24h period. Using GUI Using Python Interface Scripts Parsimonious FBA","title":"Single species"},{"location":"single_species/#using-gui","text":"","title":"Using GUI"},{"location":"single_species/#using-python-interface-scripts","text":"","title":"Using Python Interface Scripts"},{"location":"single_species/#parsimonious-fba","text":"","title":"Parsimonious FBA"},{"location":"python-module/1_simple_growth/","text":"This simple example illustrates the basic workflow of COMETS, including how to build the simulation layout, to specify parameters, load the model and plot the data once the simulation is finished. The core of the COMETS methodology is the Dynamic Flux Balance Analysis algorithm (Madahevan et al 2002). One of the first successful simulations of the time dynamics of bacterial metabolism was the classical study of Escherichia coli batch culture by Varma and Palsson (1994). Here, we reproduce one of the results in that study, the anaerobic fermentation in minimal media with glucose as the only carbon source. We will simulate a test tube by setting a well-mixed virtual container with 1cm^3 1cm^3 of media, which we will inoculate with 5 \\times 10^{-6} 5 \\times 10^{-6} grams of E. coli biomass. We will set the initial composition of the substrate to 11mM of glucose and unlimited amounts of ammonia and phosphate. For the nutrient uptake, we will use standard Michaelis-Menten kinetics, using the experimentally measured Monod parameter for anaerobic uptake of glucose by E. coli . For this simple example, we use the rudimentary \"core\" model of E. coli (Orth et al. 2009), which can be downloaded in .xml format from http://bigg.ucsd.edu/models/e_coli_core, and represents an E. coli metabolism simplified to its core functions (glycolysis, tricarboxylic cycle, pentose phosphate shunt, etc). Loading the COMETS Python Toolbox We first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas. import comets as c Creating a test tube We are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration. # Create empty 1x1 layout test_tube = c.layout() # Add 11mM glucose and remove o2 test_tube.set_specific_metabolite('glc__D_e', 0.011) test_tube.set_specific_metabolite('o2_e', 0) # Add the rest of nutrients unlimited (ammonia, phosphate, water and protons) test_tube.set_specific_metabolite('nh4_e',1000); test_tube.set_specific_metabolite('pi_e',1000); test_tube.set_specific_metabolite('h2o_e',1000); test_tube.set_specific_metabolite('h_e',1000); Loading a model Next, we have to load the model and add it to the layout (or \"inoculate it in our test tube\"). Under the hood, the comets model class uses the CobraPy package to load models, and actually comets model class can be instantiated also with a loaded CobraPy model as input. In our experience, this has been very useful when using CobraPy and COMETS back and forth to perform different types of simulations and analysis. In this case, we load our model from the .xml file we downloaded. We then remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at 10-6 gr. # load the model e_coli = c.model('test_models/e_coli_core.xml') e_coli.change_bounds('EX_glc__D_e', -1000, 1000) # set its initial biomass, 5e-6 gr at coordinate [0,0] e_coli.initial_pop = [0, 0, 5e-6] # add it to the test_tube test_tube.add_model(e_coli) Setting the simulation parameters We next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters. # Set the parameters that are different from the default sim_params = c.params() sim_params.all_params['defaultVmax'] = 18.5 sim_params.all_params['defaultKm'] = 0.000015 sim_params.all_params['maxCycles'] = 1000 sim_params.all_params['timeStep'] = 0.01 sim_params.all_params['spaceWidth'] = 1 sim_params.all_params['maxSpaceBiomass'] = 10 sim_params.all_params['minSpaceBiomass'] = 1e-11 sim_params.all_params['writeMediaLog'] = True Running the simulation With all set up, we can now instantiate the comets class by passing the layout (containing the model ) and the params objects we just created. well_mixed = c.comets(test_tube, sim_params) Finally, we can run the simulation as: well_mixed.run() Analyzing the results The results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field. well_mixed.total_biomass.plot(x = 'cycle') Similarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM. media = well_mixed.media.copy() media = media[media.conc_mmol<900] fig, ax = plt.subplots() media.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol') ax.legend(('acetate','ethanol', 'formate', 'glucose'))","title":"Growth in a test tube"},{"location":"python-module/1_simple_growth/#loading-the-comets-python-toolbox","text":"We first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas. import comets as c","title":"Loading the COMETS Python Toolbox"},{"location":"python-module/1_simple_growth/#creating-a-test-tube","text":"We are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration. # Create empty 1x1 layout test_tube = c.layout() # Add 11mM glucose and remove o2 test_tube.set_specific_metabolite('glc__D_e', 0.011) test_tube.set_specific_metabolite('o2_e', 0) # Add the rest of nutrients unlimited (ammonia, phosphate, water and protons) test_tube.set_specific_metabolite('nh4_e',1000); test_tube.set_specific_metabolite('pi_e',1000); test_tube.set_specific_metabolite('h2o_e',1000); test_tube.set_specific_metabolite('h_e',1000);","title":"Creating a test tube"},{"location":"python-module/1_simple_growth/#loading-a-model","text":"Next, we have to load the model and add it to the layout (or \"inoculate it in our test tube\"). Under the hood, the comets model class uses the CobraPy package to load models, and actually comets model class can be instantiated also with a loaded CobraPy model as input. In our experience, this has been very useful when using CobraPy and COMETS back and forth to perform different types of simulations and analysis. In this case, we load our model from the .xml file we downloaded. We then remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at 10-6 gr. # load the model e_coli = c.model('test_models/e_coli_core.xml') e_coli.change_bounds('EX_glc__D_e', -1000, 1000) # set its initial biomass, 5e-6 gr at coordinate [0,0] e_coli.initial_pop = [0, 0, 5e-6] # add it to the test_tube test_tube.add_model(e_coli)","title":"Loading a model"},{"location":"python-module/1_simple_growth/#setting-the-simulation-parameters","text":"We next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters. # Set the parameters that are different from the default sim_params = c.params() sim_params.all_params['defaultVmax'] = 18.5 sim_params.all_params['defaultKm'] = 0.000015 sim_params.all_params['maxCycles'] = 1000 sim_params.all_params['timeStep'] = 0.01 sim_params.all_params['spaceWidth'] = 1 sim_params.all_params['maxSpaceBiomass'] = 10 sim_params.all_params['minSpaceBiomass'] = 1e-11 sim_params.all_params['writeMediaLog'] = True","title":"Setting the simulation parameters"},{"location":"python-module/1_simple_growth/#running-the-simulation","text":"With all set up, we can now instantiate the comets class by passing the layout (containing the model ) and the params objects we just created. well_mixed = c.comets(test_tube, sim_params) Finally, we can run the simulation as: well_mixed.run()","title":"Running the simulation"},{"location":"python-module/1_simple_growth/#analyzing-the-results","text":"The results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field. well_mixed.total_biomass.plot(x = 'cycle') Similarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM. media = well_mixed.media.copy() media = media[media.conc_mmol<900] fig, ax = plt.subplots() media.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol') ax.legend(('acetate','ethanol', 'formate', 'glucose'))","title":"Analyzing the results"},{"location":"python-module/2_competition/","text":"Competition experiments are frequently performed in the laboratory to assay, for example, the fitness of a mutant in competition to the wild-type. Here, we simulate one such experiment involving E. coli and a nonessential but deleterious mutation involving the deletion of the triose phosphate isomerase reaction from glycolysis. We start by creating a layout (\"world\") and setting the initial nutrient supply. # Start by loading required packages, including the COMETS toolbox import comets as c import pandas as pd # create an empty layout world = c.layout() # Add glucose and remove o2 world.set_specific_metabolite('glc__D_e', 0.01) We will now add the typical trace metabolites to the layout we generated (including oxygen). These metabolites will be considered as static by the simulation. The static option implies that a metabolite is set to a given value and kept constant throughout the simulation. This is useful, for example, for media components that we want to be always in excess. # Add typical trace metabolites and oxygen coli as static trace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e', 'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e'] for met in trace_metabolites: newrow = {'metabolite': met, 'g_refresh': 0, 'g_static': 1, 'g_static_val': 1000, 'init_amount': 1000, 'diff_c': world.default_diff_c} newrow = pd.DataFrame([newrow], columns=newrow.keys()) world.media = pd.concat([world.media, newrow], axis=0, sort=False) Now, we load the E. coli iJO1366 model, and create also a KO mutant for the triose phosphate isomerase reaction. We do this by setting both upper and lower bounds to zero. We then add both models to our layout . # load the wild-type model wt = c.model('test_models/iJO1366.xml') # load the wild-type model and construct the mutant mut = c.model('test_models/iJO1366.xml') mut.change_bounds('TPI', 0,0) mut.id = 'TPI_iJO1366' # set the initial biomasses for both models wt.initial_pop = [0, 0, 5e-8] mut.initial_pop = [0, 0, 5e-8] # add the models to the layout world.add_model(wt) world.add_model(mut) We need also to create a parameters object and modify needed parameters. In this case, we will modify only the number of cycles the simulation runs. comp_params = c.params() comp_params.all_params['maxCycles'] = 240 Finally, we pass all of the above to a comets object, and run the competition assay. comp_assay = c.comets(world, comp_params) comp_assay.run() Now, we can plot the biomasses of these two genotypes in co-culture. biomass = comp_assay.total_biomass biomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep'] import matplotlib.pyplot as plt myplot = biomass.drop(columns=['cycle']).plot(x = 't') We can also compute the competitive fitness of the mutant with respect to the wild type, as the ratio of the biomass increase of the mutant divided by that of the wild-type: cfit = (biomass.loc[biomass['t'] == 24, 'TPI_iJO1366'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_iJO1366'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'iJO1366'].iloc[0]/biomass.loc[biomass['t'] == 0, 'iJO1366'].iloc[0]) Serial transfers and competitive exclusion To illustrate the serial transfer capabilities of COMETS, we will now simulate a serial transfer competition between these two genotypes. We will just create a different set of parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same \"world\" layout as before. Note When performing serial transfers, the biomass is discretized according to the cellSize parameter. This allows for stochastic sampling when the bottleneck is applied, which can be important if some species are present at low density. The value of cellSize must be always bigger than the minimal biomass allowed for a model in a cell (defined by the minCellBiomass parameter). serial_params = c.params() serial_params.all_params['maxCycles'] = 240*25 # simulate 4 serial transfers of 24h each serial_params.all_params['batchDilution'] = True serial_params.all_params['dilFactor'] = 0.01 serial_params.all_params['dilTime'] = 24 serial_params.all_params['cellSize'] = 1e-9 We now run the simulation serial_expt = c.comets(world, serial_params) serial_expt.run() And plot the biomasses of the two species during an experiment with 25 transfers every 24h biomass = serial_expt.total_biomass biomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24 myplot = biomass.drop(columns=['cycle', 't']).plot(x = 'transfer')","title":"Competition assay"},{"location":"python-module/2_competition/#serial-transfers-and-competitive-exclusion","text":"To illustrate the serial transfer capabilities of COMETS, we will now simulate a serial transfer competition between these two genotypes. We will just create a different set of parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same \"world\" layout as before. Note When performing serial transfers, the biomass is discretized according to the cellSize parameter. This allows for stochastic sampling when the bottleneck is applied, which can be important if some species are present at low density. The value of cellSize must be always bigger than the minimal biomass allowed for a model in a cell (defined by the minCellBiomass parameter). serial_params = c.params() serial_params.all_params['maxCycles'] = 240*25 # simulate 4 serial transfers of 24h each serial_params.all_params['batchDilution'] = True serial_params.all_params['dilFactor'] = 0.01 serial_params.all_params['dilTime'] = 24 serial_params.all_params['cellSize'] = 1e-9 We now run the simulation serial_expt = c.comets(world, serial_params) serial_expt.run() And plot the biomasses of the two species during an experiment with 25 transfers every 24h biomass = serial_expt.total_biomass biomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24 myplot = biomass.drop(columns=['cycle', 't']).plot(x = 'transfer')","title":"Serial transfers and competitive exclusion"},{"location":"python-module/3_chemostat/","text":"COMETS provides the functionality to run simulations in a chemostat. Here we are going to simulate a chemostat with lactose as the sole carbon resource and two strains of E. coli: one which is deficient in the ability to uptake lactose, and one which is deficient in the ability to metabolize galactose. We will use the ijo1366 model provided as part of cobrapy. We will illustrate two ways in which chemostat simulations can be performed using the Comets Python toolbox: 1) by manually assigning all the \"parts,\" and 2) by using a helper function that is included. Let's load that first, make a copy, then knock-out the relevant reactions. import cobra import cobra.test import comets as c E_no_galE = cobra.test.create_test_model('ecoli') # this model will have galE KO'd E_no_LCTStex = E_no_galE.copy() # here we'll KO lactose uptake Note that the first model had galE knocked out to prevent metabolism of galactose, which will cause it to be secreted. The second model has a reaction knocked out instead of a gene, as lactose transport to the periplasm can be accomplished with multiple genes, and it is simpler to just knockout the reaction itself. We can test that the knockouts perform as expected by trying to grow them in media containing lactose and galactose: medium = E_no_galE.medium medium[\"EX_glc_e\"] = 0. medium[\"EX_lcts_e\"] = 1. medium[\"EX_gal_e\"] = 1. # medium: {'EX_ca2_e': 1000.0, 'EX_cbl1_e': 0.01, 'EX_cl_e': 1000.0, 'EX_co2_e': 1000.0, 'EX_cobalt2_e': 1000.0, 'EX_cu2_e': 1000.0, 'EX_fe2_e': 1000.0, 'EX_fe3_e': 1000.0, 'EX_gal_e': 1.0, 'EX_h_e': 1000.0, 'EX_h2o_e': 1000.0, 'EX_k_e': 1000.0, 'EX_lcts_e': 1.0, 'EX_mg2_e': 1000.0, 'EX_mn2_e': 1000.0, 'EX_mobd_e': 1000.0, 'EX_na1_e': 1000.0, 'EX_nh4_e': 1000.0, 'EX_ni2_e': 1000.0, 'EX_o2_e': 1000.0, 'EX_pi_e': 1000.0, 'EX_sel_e': 1000.0, 'EX_slnt_e': 1000.0, 'EX_so4_e': 1000.0, 'EX_tungs_e': 1000.0, 'EX_zn2_e': 1000.0, 'EX_glc_e': 0.0} E_no_galE.medium = medium E_no_LCTStex.medium = medium # running the below functions shows growth in each case, but only using # lactose in the first case and only using galactose in the second case. # Additionally, we see that E_no_galE secretes galactose during growth on lactose. E_no_galE.summary() E_no_LCTStex.summary() Now we are ready to setup a COMETS simulation. Let's intend that the medium shown above is the reservoir (except that we will remove the galactose first), and the input rate and output rate are 10% / hr. Let's set that parameter and make our COMETS models. # chemostat parameters: dilution_rate = 0.1 # / hr initial_pop = 1e-3 # Make the models into COMETS models: E_no_galE.id = \"galE_KO\" E_no_LCTStex.id = \"LCTStex_KO\" E_no_galE = c.model(E_no_galE) E_no_galE.initial_pop = [0, 0, initial_pop] # next line allows medium to constrain uptake E_no_galE.reactions.loc[E_no_galE.reactions.EXCH, 'LB'] = -1000 E_no_LCTStex = c.model(E_no_LCTStex) E_no_LCTStex.initial_pop = [0, 0, initial_pop] # next line allows medium to constrain uptake E_no_LCTStex.reactions.loc[E_no_LCTStex.reactions.EXCH, 'LB'] = -1000 Now we are going to use the manual method for making a chemostat. Recall that Cobra mediums are set using exchange reaction ids, whereas COMETS media are set using metabolite ids. We can easily take care of this with a dictionary comprehension. Here we do that, then generate a layout, and add to it the medium. # setup layout comets_media = {key[3:] : value for key, value in medium.items() if key != \"EX_gal_e\"} layout = c.layout([E_no_galE, E_no_LCTStex]) # set initial media for key, value in comets_media.items(): layout.set_specific_metabolite(key, value) The input of fresh media from the reservoir into the simulation is done using media_refresh. Metabolites with a media_refresh value are replenished at the specified amount per-hour. Since we are diluting at 0.1 per hour, we multiply the reservoir concentration by this rate. # set metabolite drip for key, value in comets_media.items(): layout.set_specific_refresh(key, value * dilution_rate) The rest of the chemostat\u2014the output flow\u2014is setup in the parameters using the metaboliteDilutionRate and deathRate parameters, which should be set equal to our dilution rate: params = c.params() params.all_params['deathRate'] = dilution_rate params.all_params['metaboliteDilutionRate'] = dilution_rate Let's also change a few other parameters. params.all_params['timeStep'] = 0.1 params.all_params[\"maxSpaceBiomass\"] = 10 params.all_params['maxCycles'] = 2000 Finally, lets keep track of just a few key metabolites: lactose and galactose. We do this using the specificMedia log, and choosing the metabolites with a comma-separated list with no spaces. params.all_params['writeSpecificMediaLog'] = True params.all_params['specificMediaLogRate'] = 1 params.all_params['specificMedia'] = 'lcts_e,gal_e' Now we can generate a COMETS simulation object, run it, then examine the biomass and metabolites. sim = c.comets(layout, params) sim.run() sim.total_biomass.plot(x = \"cycle\") # in the next line, we exclude the x and y columns, as this was not a spatial simulation sim.specific_media.ix[:, sim.specific_media.columns.difference([\"x\",\"y\"])].plot(x = \"cycle\") We see that both species survive, with LCTStex_KO cross-feeding galactose. The metabolites, as is typical in chemostat, are in very low concentrations once equilibrium is reached. The above code required setting chemostat parameters in multiple places. We offer this functionality so that researchers can create complex setups that may, for example, have different initial concentrations than reservoir concentrations, and different inflow rates than outflow rates. However, we expect most chemostat simulations will function like above, where a single dilution parameter dictates the behavior of the system. For this, we have made a helper function which generates a layout and parameters file with the correct setup: # here the first argument is a list of comets models, the second the reservoir media, and the third is the dilution rate layout, params = c.chemostat([E_no_galE, E_no_LCTStex], comets_media, dilution_rate) # we can then adjust other parameters as desired, and run. params.all_params['timeStep'] = 0.1 params.all_params[\"maxSpaceBiomass\"] = 10 params.all_params['maxCycles'] = 2000 params.all_params['writeSpecificMediaLog'] = True params.all_params['specificMediaLogRate'] = 1 params.all_params['specificMedia'] = 'lcts_e,gal_e' sim = c.comets(layout, params) sim.run() sim.total_biomass.plot(x = \"cycle\") sim.specific_media.ix[:, sim.specific_media.columns.difference([\"x\",\"y\"])].plot(x = \"cycle\")","title":"Continuous culture"},{"location":"python-module/4_evolution/","text":"One of COMETS features is the ability to include mutations in models during a simulation, thereby simulating evolution. At the moment, mutations consist in either reaction deletions or additions. In this example, we simulate an experimental evolution of E. coli in batch culure, with serial transfers every 24 hours. We start as usual by loading the toolbox and setting up the layout. We will use a well mixed environment with a glucose minimal media. import comets as c import os import pandas as pd import matplotlib.pyplot as plt # generate layout world = c.layout() world.set_specific_metabolite('glc__D_e', 0.01) AddWe also add trace metabolites (ions, metals etc) in unlimited amounts. For this, we set the static flag to True and the static value to 1000mM. # Add typical trace metabolites and oxygen coli as static trace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e', 'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e'] for met in trace_metabolites: newrow = {'metabolite': met, 'g_refresh': 0, 'g_static': 1, 'g_static_val': 1000, 'init_amount': 1000, 'diff_c': world.default_diff_c} newrow = pd.DataFrame([newrow], columns=newrow.keys()) world.media = pd.concat([world.media, newrow], axis=0, sort=False) We load our model and add it to the layout # load model wt = c.model('test_models/UiJO1366_nonTrimmed.cmd') wt.initial_pop = [0, 0, 5e-8] world.add_model(wt) We now create a params object, and modify the needed parameters. For this small example, we will perform 10 transfers every 24h. We will set the mutation rate to 10^6 10^6 for deletions. We also set a cost term for genome size of 5e-8, so that deletion of useless mutations can be slightly beneficial due to reduction in genome maitenance. # .. load parameters and layout from file evo_params = c.params() #simulate 10 serial transfers of 24h each (timeStep = 0.1) evo_params.all_params['timeStep'] = 0.1 evo_params.all_params['maxCycles'] = 2400 evo_params.all_params['batchDilution'] = True evo_params.all_params['dilFactor'] = 0.01 evo_params.all_params['dilTime'] = 24 evo_params.all_params['evolution'] = True evo_params.all_params['mutRate'] = 1e-5 evo_params.all_params['cellSize'] = 1e-9 #evo_params.all_params['minCellBiomass'] = 2.5e-13 evo_params.all_params['costlyGenome'] = True evo_params.all_params['geneFractionalCost'] = 5e-8 evo_params.all_params['BiomassLogRate'] = 1 #2400 Finally, we create the COMETS object using the above layout and parameters, and run the simulation. # create comets object from the loaded parameters and layout evo_simulation = c.comets(world, evo_params) # run comets simulation evo_simulation.run() We can visualize the evolution over time using the biomass output data frame. fig, ax = plt.subplots(figsize=(15, 5)) for key, grp in evo_simulation.biomass.groupby(['species']): ax = grp.plot(ax=ax, kind='line', x='Cycle', y='biomass') ax.get_legend().remove() plt.yscale('log') plt.show() It is also helpful to the analyze the genotype data frame output. This table contains all the mutants that appear during the simulation, in three columns: The ancestor, the mutation, and the name of the resulting genotype, which is assigned a random hash as ID (or \"Species\"). Note that the first genotype in the list is the loaded model, so it has \"no ancestor\" and \"no mutation\". Evo_simulation.genotypes Ancestor Mutation Species 0 NO_ANCESTOR NO_MUT UiJO1366_nonTrimmed.cmd 1 UiJO1366_nonTrimmed.cmd add_5510 e242b9ca-e8ea-46ab-aaeb-09b24b690d6c 2 UiJO1366_nonTrimmed.cmd del_1214 4c1d16f3-976e-446b-87d2-3126d8a4310f 3 UiJO1366_nonTrimmed.cmd add_2944 46ffd601-3ca7-4d63-93ee-88c7dee6ea03 4 UiJO1366_nonTrimmed.cmd add_5172 9cd5b1a8-5768-4e1c-8c55-2f0271f9ee36 5 UiJO1366_nonTrimmed.cmd del_1709 fb39194a-9892-4942-b817-5261b2bd0da6 . ... ... ...","title":"Simulating evolution with COMETS"},{"location":"python-module/5_citrate/","text":"After 33,000 generations a large population expansion was observed in the Ara-3 population of the E. coli long-term evolution experiment (Blount et al 2008). This population expansion was found to be associated with two key mutations that together enable the evolution of strong aerobic citrate utilization (Cit++ phenotype). The first mutation, occurring roughly 31,000 generations, caused the aerobic expression of the citT transporter, producing a weak citrate growth phenotype (Cit+, Blount et al 2012). A subsequent mutation, occurring roughly 33,000 generations, caused high-level, constitutive expression of dctA, a proton-driven dicarboxylic acid transporter (Quandt et al 2014). Because these two mutations introduce known reactions into the e.coli metabolic network we can simulate them using COMETS. In this example, we illustrate how we can simulate the appearance of these two mutations in the E. coli population growing under the LTEE conditions (24hr batch culture in DM25). For this, we will sequentially introduce the mutations as they appear in the population, and observe their effects in the context of the population in which they appear. This simulation uses the same models, parameters and genotypes outlined in (Bajic et al 2018). We first load the toolbox, create the layout and simulate the DM25 medium. %matplotlib inline import comets as c import matplotlib as plt import cobra import pandas as pd import numpy as np layout = c.layout() #Set up media to be DM25 flask.add_typical_trace_metabolites() flask.set_specific_metabolite('glc__D_e', 0.000139) flask.set_specific_metabolite('cit_e', 0.0017) We next load the model and build the mutants. To show the compatibility with the COBRApy toolbox, we will load the model and perform the mutations using COBRA, and then pass these models as input to build COMETS models. Unlike the LTEE ancestral strain REL606 (and E. coli in general), which possess the necessary genes for citrate utilization but do not express them in aerobic conditions, iJO1366 is able utilize both citrate and succinate as these reactions are unbounded by default. Thus, the ancestral phenotype can be recreated by knocking out three reactions CITt7pp (citT), SUCCt2_2pp (dctA) and SUCCt2_3pp (dcuA or dcuB). # Load the original E. coli model mod = cobra.io.read_sbml_model('test_models/iJO1366.xml') # Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS for i in mod.reactions: if 'EX_' in i.id: i.lower_bound =-1000.0 # Create the mutants mod.reactions.SUCCt2_3pp.upper_bound=0.0 CitTdctA = mod.copy() mod.reactions.SUCCt2_2pp.upper_bound =0.0 CitT = mod.copy() mod.reactions.CITt7pp.upper_bound =0.0 WT = mod.copy() WT.id= 'Ancestor' CitT.id = 'Cit+' CitTdctA.id = 'Cit++' # Generate comets models from COBRA models and set their initial population size # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift p = c.model(WT) p.initial_pop = [0, 0, 3.9e-11] p2 = c.model(CitT) p2.initial_pop = [0, 0, 0] # not present at start p3 = c.model(CitTdctA) p3.initial_pop = [0, 0, 0] # not present at start # Add the models to the simulation flask.add_model(p) flask.add_model(p2) flask.add_model(p3) We now set the parameters for the simulation. We use 1 hr as the COMETS timestep to speed up the simulation. Shortening this to the more commonly used 0.1 hr does not substantially affect the final result, but it does significantly increase the time it takes this simulation to run. ### Setting paramaters for the simulation ### ltee_params = c.params() ltee_params.all_params['timeStep'] = 1.0 ltee_params.all_params['deathRate'] = 0.01 ltee_params.all_params['batchDilution'] =True ltee_params.all_params['dilTime'] =24 ltee_params.all_params['dilFactor'] =100 ltee_params.all_params['cellSize']= 3.9e-13 ltee_params.all_params['minSpaceBiomass'] = 3.8e-13 Now perform the simulations. We will divide our simulation in three COMETS runs (phase 1, 2 and 3). We will start the simulation at generation 25000 and run for around 6000 generations. At roughly generation 31,000, we introduce the CitT genotype and run for around 2000 Generations. Finally, at roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generations. For each run, we will input the final biomass composition of the previous run. Each phase stores the biomass data in a separate separate dataframe that we will ultimately join together for analysis. # We'll start at Generation 25,000. and run for around 6000 generations cycles_per_day = 24.0/ltee_params.all_params['timeStep'] ltee_cit_simulation = c.comets(flask, ltee_params) ltee_cit_simulation.parameters.all_params['maxCycles'] = int(900*cycles_per_day) ltee_cit_simulation.run() ltee_cit_simulation = c.comets(flask, ltee_params) ltee_cit_simulation.parameters.all_params['maxCycles'] = int(900*cycles_per_day) phase_1 = pd.DataFrame({'Ancestor' : ltee_cit_simulation.total_biomass.Ancestor/(3.9e-13), 'CitT' : ltee_cit_simulation.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : ltee_cit_simulation.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(ltee_cit_simulation.total_biomass.cycle+1)/cycles_per_day + 25000}) # At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations ltee_cit_simulation.flask.models[0].initial_pop = [0, 0, float(ltee_cit_simulation.total_biomass.Ancestor.tail(1))] ltee_cit_simulation.flask.models[1].initial_pop = [0, 0, 3.9e-11] ltee_cit_simulation.flask.build_initial_pop() ltee_cit_simulation.parameters.all_params['maxCycles'] = int(300*cycles_per_day) ltee_cit_simulation.run() phase_2 = pd.DataFrame({'Ancestor' : ltee_cit_simulation.total_biomass.Ancestor/(3.9e-13), 'CitT' : ltee_cit_simulation.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : ltee_cit_simulation.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(ltee_cit_simulation.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)}) # At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr ltee_cit_simulation.flask.models[0].initial_pop = [0, 0, float(ltee_cit_simulation.total_biomass.Ancestor.tail(1))] ltee_cit_simulation.flask.models[1].initial_pop = [0, 0, float(ltee_cit_simulation.total_biomass['Cit+'].tail(1))] ltee_cit_simulation.flask.models[2].initial_pop = [0, 0, 3.9e-11] ltee_cit_simulation.flask.build_initial_pop() ltee_cit_simulation.parameters.all_params['maxCycles'] = int(900*cycles_per_day) ltee_cit_simulation.run() phase_3 = pd.DataFrame({'Ancestor' : ltee_cit_simulation.total_biomass.Ancestor/(3.9e-13), 'CitT' : ltee_cit_simulation.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : ltee_cit_simulation.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(ltee_cit_simulation.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) }) Finally, group all the results from the three runs together and plot the stationary phase population size through time. #Remove the final time point from each phase phase_1.drop(phase_1.tail(1).index, inplace=True) phase_2.drop(phase_2.tail(1).index, inplace=True) phase_3.drop(phase_3.tail(1).index, inplace=True) final_df = pd.concat([phase_1,phase_2,phase_3]) final_df.reindex() final_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67] final_df.plot(x='Generations', ylog=True)","title":"Citrate use in the LTEE"},{"location":"python-module/6_extracell_rxns/","text":"This protocol demonstrates the capacity of COMETS to simulate reactions occuring in the extracellular environment. Extracellular reaction information is included in the COMETS layout file, in blocks with the following format: REACTANTS rxnIdx metIdx order k //elemental rxn rxnIdx metIdx km //enzyme catalyzed ENZYMES rxnIdx metIdx kcat PRODUCTS rxnIdx metIdx stoich // Each reactant or product in a given reaction should appear on its own line, using the same integer rxnIdx per extracellular reaction. The metIdx field corresponds to a metabolite\u2019s position in the world_media block. The system determines whether a reaction is elemental or enzymatic based on the presence of an entry in the ENZYMES block. In the case of elemental reactions, only the first entry for the rate constant k is used. TODO: example simulation, implement in py toolbox","title":"Extracellular reactions"},{"location":"python-module/6_extracell_rxns/#todo-example-simulation-implement-in-py-toolbox","text":"","title":"TODO: example simulation, implement in py toolbox"},{"location":"python-module/8_demographic/","text":"","title":"Demographic noise and cooperative propagation in space"},{"location":"python-module/9_soil_air_interface/","text":"One can make a complex, realistic environment in COMETS with relative simplicity. Here, we demonstrate how to simulate a 2d cross-section of soil with three different species, a \u201croot\u201d along the left side, \u201cair\u201d along the top, and multiple impenetrable rocks. We begin by downloading three soil bacteria models as .xml files from the BiGG database (King et al. 2015): the Bacillus subtilis model iYO844, the Pseudomonas putida model iJN747, and the Methanosarcina barkeri model iAF629. We load these models into a python environment using the Cobra toolbox. Also, upon downloading, the biomass functions of these models had positive lower bounds, which we then set to zero: import cobra import comets as c iJN = cobra.io.read_sbml_model('iJN746.xml') iJN.reactions.get_by_id('BIOMASS_KT_TEMP').lower_bound = 0 iJN.reactions.get_by_id('BIOMASS_KT_TEMP').upper_bound = 1000 iAF = cobra.io.read_sbml_model('iAF692.xml') iAF.reactions.get_by_id('BIOMASS_Mb_30').lower_bound = 0 iAF.reactions.get_by_id('BIOMASS_Mb_30').upper_bound = 1000 iYO = cobra.io.read_sbml_model('iYO844.xml') iYO.reactions.get_by_id('BIOMASS_BS_10').lower_bound = 0 iYO.reactions.get_by_id('BIOMASS_BS_10').upper_bound = 1000 Next, we convert these into COMETS models. (Side note: A difficult design choice was made in having a specific COMETS model object, rather than just using a Cobra object. The reason we used a separate COMETS model object was because in Cobra, media environments are an intrinsic part of the Cobra model, and are generated by altering flux bounds on exchange reactions. In COMETS, assuming the model is a wild-type, the exchange reaction flux bounds should always be open, and the media environment is not part of the model, but part of the layout. Our intent in making a specific COMETS model object was to hopefully reduce the chance that Cobra users would attempt to set the media environment by making changes to the COMETS model. ) We also ensure the model does not think that sink reactions are exchange reactions (as they are unbalanced in Cobra models, and therefore appear similar to exchanges), and open all exchange reaction bounds: iJN_comets = c.model(iJN) iJN_comets = ensure_sinks_are_not_exchanges(iJN_comets) # note to self, make these model-owner methods iJN_comets = open_exchanges(iJN_comets) iAF_comets = c.model(iAF) iAF_comets = ensure_sinks_are_not_exchanges(iAF_comets) iAF_comets = open_exchanges(iAF_comets) iYO_comets = c.model(iYO) iYO_comets = ensure_sinks_are_not_exchanges(iYO_comets) iYO_comets = open_exchanges(iYO_comets) Our simulated world will be a 100x100 box lattice. The left-hand side, where x = 0, will be the root. The top, where y = 0, will be the air. Therefore, the biomass and the rocks will be distributed everywhere else. To ensure that we don't attempt to place biomass where rocks are placed, we first determine the rock locations. Specifically, we will create 70 rocks which are impervious to any biomass or metabolite. These rocks will have an average size of 15 boxes. To pick these locations, we use the helper function grow_rocks: rock_locs = grow_rocks(n = 70, xrange = [1,100],yrange = [1,100],mean_size = 15) Each species will have biomass seeded at 60 different locations, with no overlap. We will use the helper function pick_random_locations for this, which is useful as it can take in a previously-generated list of tuples of x-y locations as \u201cforbidden\u201d locations, such as the rock locations. First we make a copy of the rock_locs so we don't accidentally alter it, and call this copy forbidden_locs. import copy forbidden_locs = copy.deepcopy(rock_locs) Next we pick the random locations for each species, adding these locations to the forbidden locs as we go so as to prevent overlap. iJN_locs = pick_random_locations(n = 60, xrange = [1,100], yrange = [1,100], forbidden_locs = forbidden_locs) forbidden_locs.extend(iJN_locs) iYO_locs = pick_random_locations(60, [1,100],[1,100], forbidden_locs) forbidden_locs.extend(iYO_locs) iAF_locs = pick_random_locations(60, [1,100],[1,100], forbidden_locs) forbidden_locs.extend(iAF_locs) # note to self: put this somewhere logical in the toolbox If we wish to take a look at what locations were chosen, we can easily make an image with matplotlib (see Figure XXX): from matplotlib import pyplot as plt initial_image = np.zeros((100,100,3)) for rock in rock_locs: initial_image[rock[1]-1,rock[0]-1,0:3] = 0.5 for loc in iJN_locs: initial_image[loc[1]-1,loc[0]-1,0] = 1 for loc in iYO_locs: initial_image[loc[1]-1,loc[0]-1,1] = 1 for loc in iAF_locs: initial_image[loc[1]-1,loc[0]-1,2] = 1 plt.imshow(initial_image) ``` Things look good so we continue by making the layout and setting the dimensions. Then, we add the rock barriers to the layout. ```Py layout = c.layout() layout.grid = [100,100] layout.add_barriers(rock_locs) We set the initial population for each species by using a python list comprehension. Note that locations are properties of the model (NOTE maybe I should change this to layout, and make it something like layout.set_initial_pop(species_id, locs, biomass). iJN_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iJN_locs] iYO_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iYO_locs] iAF_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iAF_locs] We add the models to the layout. layout.add_model(iJN_comets) layout.add_model(iYO_comets) layout.add_model(iAF_comets) We want some metabolites available initially. These include all the typical trace nutrients needed, so we start with the helper function. layout.add_typical_trace_metabolites() However, we want oxygen to mostly diffuse from the air, so we set that value lower. We also add a few other trace metabolites homogeneously throughout the environm At this point we make a COMETS instance and run the model. Be aware that on a modern mid-range computer, this could take more than 5 hours. Set the parameter 'maxCycles' to something smaller if you wish to conduct a test. Note that we set delete_files = False. If one is running fast simulations such as in a single box, it is convenient to leave this as true to keep the file structure clean. However, for long-running simulations, it makes more sense to keep file records of the simulation settings and data, in case the python kernel is shutdown. spatial = c.comets(layout, params) spatial.run(delete_files = False) # takes hours! (todo: decide whether we want the python toolbox to read total biomass / biomass / media files, or whether we state that that is \u201ca typical python task\u201d and leave it up to the reader. I have functions which parse the data out of the MATLAB results which used to be spit out of the comets runs (which is what I'm still doing, heh), but I haven't written anything for whatever the new format is) Once complete, the location-specific biomass and media information are in files which are specified in the params, as is the summarized total biomass data: params.all_params['BiomassLogName'] params.all_params['MediaLogName'] params.all_params['TotalBiomassLogName'] These files can be easily parsed with your favorite data analysis tool. For the figures below, we loaded the data into numpy arrays and visualized them with matplotlib functions, as in previous protocols.","title":"Natural environments"},{"location":"python-module/colony/","text":"Simulating the growth of a colony We demonstrate here a simple COMETS simulation with space, the growth of an E. coli colony using a 2D spatial lattice. import comets as c import os import pandas as pd import matplotlib.pyplot as plt import matplotlib.cm, matplotlib.colors import copy pd.options.display.max_rows = 10 As usual, we first create a parameters object using the params class. my_params = c.params() my_params.all_params['maxCycles'] = 300 my_params.all_params['writeBiomassLog'] = True We next load a layout for our simulation my_layout = c.layout('test_colony/colony_layout') my_layout.initial_pop [[10.0, 10.0, 1e-07]] # create comets object from the loaded parameters and layout my_comets = c.comets(my_layout, my_params) # run comets simulation my_comets.run() Running COMETS simulation ... Done! We can print the stderr and stdout, which are stored in the run_errors and run_output fields: print(my_comets.run_errors) STDERR empty. And here is how our incipient E. coli colony looks like: import numpy as np biomass_END = np.zeros((my_layout.grid[0], my_layout.grid[1])) aux = my_comets.biomass.loc[my_comets.biomass['Cycle'] == 300] for index, row in aux.iterrows(): biomass_END[row['x'], row['y']] = row['biomass'] my_cmap = copy.copy(matplotlib.cm.get_cmap('copper')) # copy the default cmap my_cmap.set_bad((0,0,0)) plt.imshow(biomass_END, interpolation='nearest', norm=matplotlib.colors.LogNorm(), cmap=my_cmap)","title":"Growth of an E. coli colony"},{"location":"python-module/colony/#simulating-the-growth-of-a-colony","text":"We demonstrate here a simple COMETS simulation with space, the growth of an E. coli colony using a 2D spatial lattice. import comets as c import os import pandas as pd import matplotlib.pyplot as plt import matplotlib.cm, matplotlib.colors import copy pd.options.display.max_rows = 10 As usual, we first create a parameters object using the params class. my_params = c.params() my_params.all_params['maxCycles'] = 300 my_params.all_params['writeBiomassLog'] = True We next load a layout for our simulation my_layout = c.layout('test_colony/colony_layout') my_layout.initial_pop [[10.0, 10.0, 1e-07]] # create comets object from the loaded parameters and layout my_comets = c.comets(my_layout, my_params) # run comets simulation my_comets.run() Running COMETS simulation ... Done! We can print the stderr and stdout, which are stored in the run_errors and run_output fields: print(my_comets.run_errors) STDERR empty. And here is how our incipient E. coli colony looks like: import numpy as np biomass_END = np.zeros((my_layout.grid[0], my_layout.grid[1])) aux = my_comets.biomass.loc[my_comets.biomass['Cycle'] == 300] for index, row in aux.iterrows(): biomass_END[row['x'], row['y']] = row['biomass'] my_cmap = copy.copy(matplotlib.cm.get_cmap('copper')) # copy the default cmap my_cmap.set_bad((0,0,0)) plt.imshow(biomass_END, interpolation='nearest', norm=matplotlib.colors.LogNorm(), cmap=my_cmap)","title":"Simulating the growth of a colony"},{"location":"python-module/getting_started/","text":"The Comets Python module The Comets python module is intended to offer a programatic, easy and intuitive interface to COMETS . While it internally uses the same COMETS Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results. Any comets simulation starts from a layout and a set of parameters . The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the models . The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are layout and parameters . These two are integrated in the comets class, which perform simulations and contain their output. The params class The parameters class is a dict with the parameter names and values for a simulation. If we initialize the class without arguments, it will contain the default parameter values (see here ): my_params = c.params() The class can also load comets parameters files (see the definition of these files here ). The arguments must be the two filenames corresponding to global_params and package_params : my_params = c.params('global_params_file_path', 'package_params_file_path') The parameters dict can be modified as desired. my_params.all_params['maxCycles'] = 100 The params class also contains a method to write these parameters in files with the correct format to be fed to the Java Comets engine, but this will be rarely used when working within the Comets Python environment. my_params.write_params('global_params_outfile', 'package_params_outfile') The layout class The layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in three ways: If instantiated without arguments (as my_layout = c.layout() ), an empty layout is created with all necessary fields that have to be populated. If a layout is instantiated passing a model (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000). Finally, it can also be instantiated by passing teh path to a Comets layout file . If fed models , it will create layouts with all media components those models are able to exchange with the environment, and default values for everything else. To examine the different parts of a Comets layout , let\\'s first create one from the standard E. coli model bundled with Comets. my_layout = c.layout('ecoli_model') Firstly, the layout stores information about the species ( ec_layout.models ) and spatial structure ( ec_layout.grid ) in the environment. In this case, the model is only the E. coli one and the grid is the default one, only one cell. The layout stores also information about the media as a pandas dataframe: ec_layout.media metabolite init_amount diff_c g_static g_static_val g_refresh_val ca2_e 1000 NaN 1 1000 0 cbl_e 1000 NaN 1 1000 0 cl_e 1000 NaN 1 1000 0 . . . . . . . . . . . . . . . . . . When initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media table is a pandas dataframe where several pieces of information are stored: init_amount is the initial amount to be added to each cell of the simulation grid (in mmol). diff_c indicates whether the molecule has a diffusion constant different than the default one (stored in ec_layout.global_diff ) g_static indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited. g_static_val indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1. g_refresh_val indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid. In addition, we can set local \"static\" and \"refresh\" values, i.e. specific to a cell of the simulation grid. Local refresh values are stored in a list, ec_layout.local_refresh , where each element of the list is itself a list with the form [ x y m1_r m2_r m3_r ... ] . The first two elements x and y represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in media . Local static values are stored in a similar way. Each element of the ec_layout.local_static list is itself a list with the form [ x y m1_s m1_s_v m2_s m2_s_v ... ] . The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate ( m1_s , m2_s , ... ) and another with the value at which it should be kept ( m1_s_v , m2_s_v , ... ). Note that both local_refresh and local_static can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively. Finally, the layout also contains information about the starting biomass of each model. This information is stored in two fields, initial_pop_type and initial_pop . If initial_pop_type is random : initial_pop is a list with the structure [N_i biomass_1 N_j biomass_2 ...] . This will randomly assign N_i spaces to have biomass_1 amount of model 1, and so on. If initial_pop_type is random_rect : initial_pop is a list with the structure [x y w h N_i biomass_1 N_j biomass_2 ...] . As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. If initial_pop_type is filled : initial_pop is a list with the structure [biomass_1 biomass_2 ...] . This will completely fill the grid with the given amount of biomass from each species. If initial_pop_type is filled_rect : initial_pop is a list with the structure [x y w h biomass_1 biomass_2 ...] . This will completely fill the rectangle defined by X , Y , W and H with the given amount of biomass from each species. If initial_pop_type is square : initial_pop is a list with the structure [N_i biomass_1 N_j biomass_2 ...] . This will fill squares with radius N_i at the center of the grid with the amount of biomass specified for each species. If initial_pop_type is custom : initial_pop is a list of lists, in which each entry is itself a list [x y biomass_1 biomass_2 ...]`specifying the amount of biomass of each species for each coordinate. The comets class This class represents the core of the module. It integrates the layout and the parameters, performs the simulation, and stores the output of it. Once comets is properly installed and layouts and parameters defined, running a comets simulation is pretty straightforward. We firstly define the comets object giving it a layout and a params objects as arguments. Then, we run() the simulation: my_simulation = c.comets(my_layout, my_params) my_simulation.run() In the background, this actually invokes the COMETS Java engine in a console, giving an output (stdout) and possibly errors (stderr) both of which can be acessed through the fields run_outputs and run_errors , respectively. print(my_comets.run_output) -script running script file: '/home/djordje/Dropbox/COMETS_RUN/.current_script' Loading layout file '/home/djordje/Dropbox/COMETS_RUN/.current_layout'... Found 1 model files! Loading 'EC_ijo1366_model' ... ... ... print(my_comets.run_errors) STDERR is empty. The results of the successful simulation is stored as well in several fields in the comets object, depending on whether the parameters writeTotalBiomasslog , writeBiomassLog , writeFluxLog and writeMediaLog were set to True . All of the output files ae pandas dataframes: The field total_biomass stores the total biomass (summed up over all coordinates) for each timepoint and species. The field biomass stores detailed biomass values for each timepoint, coordinate and species. The field media stores the composition of the media at each timepoint. The field fluxes stores the metabolic fluxes for each species, coordinate and timepoint. Additionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field genotypes will store information about each species such as its ancestor and which mutation it suffered. For a more detailed description of th output files, see the different examples below.","title":"Getting started"},{"location":"python-module/getting_started/#the-comets-python-module","text":"The Comets python module is intended to offer a programatic, easy and intuitive interface to COMETS . While it internally uses the same COMETS Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results. Any comets simulation starts from a layout and a set of parameters . The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the models . The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are layout and parameters . These two are integrated in the comets class, which perform simulations and contain their output.","title":"The Comets Python module"},{"location":"python-module/getting_started/#the-params-class","text":"The parameters class is a dict with the parameter names and values for a simulation. If we initialize the class without arguments, it will contain the default parameter values (see here ): my_params = c.params() The class can also load comets parameters files (see the definition of these files here ). The arguments must be the two filenames corresponding to global_params and package_params : my_params = c.params('global_params_file_path', 'package_params_file_path') The parameters dict can be modified as desired. my_params.all_params['maxCycles'] = 100 The params class also contains a method to write these parameters in files with the correct format to be fed to the Java Comets engine, but this will be rarely used when working within the Comets Python environment. my_params.write_params('global_params_outfile', 'package_params_outfile')","title":"The params class"},{"location":"python-module/getting_started/#the-layout-class","text":"The layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in three ways: If instantiated without arguments (as my_layout = c.layout() ), an empty layout is created with all necessary fields that have to be populated. If a layout is instantiated passing a model (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000). Finally, it can also be instantiated by passing teh path to a Comets layout file . If fed models , it will create layouts with all media components those models are able to exchange with the environment, and default values for everything else. To examine the different parts of a Comets layout , let\\'s first create one from the standard E. coli model bundled with Comets. my_layout = c.layout('ecoli_model') Firstly, the layout stores information about the species ( ec_layout.models ) and spatial structure ( ec_layout.grid ) in the environment. In this case, the model is only the E. coli one and the grid is the default one, only one cell. The layout stores also information about the media as a pandas dataframe: ec_layout.media metabolite init_amount diff_c g_static g_static_val g_refresh_val ca2_e 1000 NaN 1 1000 0 cbl_e 1000 NaN 1 1000 0 cl_e 1000 NaN 1 1000 0 . . . . . . . . . . . . . . . . . . When initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media table is a pandas dataframe where several pieces of information are stored: init_amount is the initial amount to be added to each cell of the simulation grid (in mmol). diff_c indicates whether the molecule has a diffusion constant different than the default one (stored in ec_layout.global_diff ) g_static indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited. g_static_val indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1. g_refresh_val indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid. In addition, we can set local \"static\" and \"refresh\" values, i.e. specific to a cell of the simulation grid. Local refresh values are stored in a list, ec_layout.local_refresh , where each element of the list is itself a list with the form [ x y m1_r m2_r m3_r ... ] . The first two elements x and y represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in media . Local static values are stored in a similar way. Each element of the ec_layout.local_static list is itself a list with the form [ x y m1_s m1_s_v m2_s m2_s_v ... ] . The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate ( m1_s , m2_s , ... ) and another with the value at which it should be kept ( m1_s_v , m2_s_v , ... ). Note that both local_refresh and local_static can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively. Finally, the layout also contains information about the starting biomass of each model. This information is stored in two fields, initial_pop_type and initial_pop . If initial_pop_type is random : initial_pop is a list with the structure [N_i biomass_1 N_j biomass_2 ...] . This will randomly assign N_i spaces to have biomass_1 amount of model 1, and so on. If initial_pop_type is random_rect : initial_pop is a list with the structure [x y w h N_i biomass_1 N_j biomass_2 ...] . As above, but the randomly assigned biomass spots are confined to a rectangle with its upper-left corner at grid space (X,Y), with W grid spaces wide, and H spaces tall. If initial_pop_type is filled : initial_pop is a list with the structure [biomass_1 biomass_2 ...] . This will completely fill the grid with the given amount of biomass from each species. If initial_pop_type is filled_rect : initial_pop is a list with the structure [x y w h biomass_1 biomass_2 ...] . This will completely fill the rectangle defined by X , Y , W and H with the given amount of biomass from each species. If initial_pop_type is square : initial_pop is a list with the structure [N_i biomass_1 N_j biomass_2 ...] . This will fill squares with radius N_i at the center of the grid with the amount of biomass specified for each species. If initial_pop_type is custom : initial_pop is a list of lists, in which each entry is itself a list [x y biomass_1 biomass_2 ...]`specifying the amount of biomass of each species for each coordinate.","title":"The layout class"},{"location":"python-module/getting_started/#the-comets-class","text":"This class represents the core of the module. It integrates the layout and the parameters, performs the simulation, and stores the output of it. Once comets is properly installed and layouts and parameters defined, running a comets simulation is pretty straightforward. We firstly define the comets object giving it a layout and a params objects as arguments. Then, we run() the simulation: my_simulation = c.comets(my_layout, my_params) my_simulation.run() In the background, this actually invokes the COMETS Java engine in a console, giving an output (stdout) and possibly errors (stderr) both of which can be acessed through the fields run_outputs and run_errors , respectively. print(my_comets.run_output) -script running script file: '/home/djordje/Dropbox/COMETS_RUN/.current_script' Loading layout file '/home/djordje/Dropbox/COMETS_RUN/.current_layout'... Found 1 model files! Loading 'EC_ijo1366_model' ... ... ... print(my_comets.run_errors) STDERR is empty. The results of the successful simulation is stored as well in several fields in the comets object, depending on whether the parameters writeTotalBiomasslog , writeBiomassLog , writeFluxLog and writeMediaLog were set to True . All of the output files ae pandas dataframes: The field total_biomass stores the total biomass (summed up over all coordinates) for each timepoint and species. The field biomass stores detailed biomass values for each timepoint, coordinate and species. The field media stores the composition of the media at each timepoint. The field fluxes stores the metabolic fluxes for each species, coordinate and timepoint. Additionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field genotypes will store information about each species such as its ancestor and which mutation it suffered. For a more detailed description of th output files, see the different examples below.","title":"The comets class"},{"location":"python-module/deprecated/batch/","text":"Batch culture in COMETS One of the most common experimental designs in microbial ecology and evolution consists on periodically transfering a small amount of a grown bacterial culture to fresh media, which is known as \"batch culture\". In COMETS , this is easily done using three parameters * batchDilution is either True or False; specifies whether periodic dilutions are performed. * dilTime is the periodicity at which dilutions are performed, in hr. * dilFactor is the dilution factor applied. If the value passed here is larger than one, that will be the dilution factor; if it is smaller than one, it will be the applied dilution properly. For instance, a 1:100 dilution can be specified as either 100 or 0.01. Let's first do a batch culture with no oxygen in the environment. import comets as c import os import pandas as pd import cobra as cb pd.options.display.max_rows = 10 # Set relevant parameters b_params = c.params() b_params.all_params['batchDilution'] = True b_params.all_params['dilTime'] = 24 b_params.all_params['dilFactor'] = 100 b_params.all_params['timeStep'] = .2 b_params.all_params['maxCycles'] = 400 # Set layout b_layout = c.layout('test_batch/batch_layout') b_layout.media.loc[b_layout.media['metabolite'] == 'glc__D_e', 'init_amount'] = 20 b_layout.media.loc[b_layout.media['metabolite'] == 'o2_e', 'init_amount'] = 0 b_layout.media .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } metabolite init_amount diff_c g_static g_static_val g_refresh 0 o2_e 0.0 NaN 0 0.0 NaN 1 glc__D_e 20.0 NaN 0 0.0 NaN 2 ca2_e 1000.0 NaN 1 1000.0 NaN 3 cbl1_e 1000.0 NaN 1 1000.0 NaN 4 cl_e 1000.0 NaN 1 1000.0 NaN ... ... ... ... ... ... ... 20 sel_e 1000.0 NaN 1 1000.0 NaN 21 slnt_e 1000.0 NaN 1 1000.0 NaN 22 so4_e 1000.0 NaN 1 1000.0 NaN 23 tungs_e 1000.0 NaN 1 1000.0 NaN 24 zn2_e 1000.0 NaN 1 1000.0 NaN 25 rows \u00d7 6 columns Now, run simulation and draw the biomass curve. # create comets object from the loaded parameters and layout batch_anaerob = c.comets(b_layout, b_params) # run comets simulation batch_anaerob.run() Running COMETS simulation ... Done! batch_anaerob.total_biomass.plot(x = 'cycle', y = 'iJO1366') Here, we see that the population is unable to reach enough density in a single cycle to maintain a stable population, an is therefore going to extinction. Lets now add oxygen to the environment, and redo the simulation. b_layout.media.loc[b_layout.media['metabolite'] == 'o2_e', 'init_amount'] = 1000 # create comets object from the loaded parameters and layout batch_aerob = c.comets(b_layout, b_params) # run comets simulation batch_aerob.run() Running COMETS simulation ... Done! batch_aerob.total_biomass.plot(x = 'cycle', y = 'iJO1366') Now, with oxygen in the environment enabling respiration, the growth rate is much higher, and the population soon reaches stationnary phase, maintaining the population through the successive dilutions.","title":"Batch culture in COMETS"},{"location":"python-module/deprecated/batch/#batch-culture-in-comets","text":"One of the most common experimental designs in microbial ecology and evolution consists on periodically transfering a small amount of a grown bacterial culture to fresh media, which is known as \"batch culture\". In COMETS , this is easily done using three parameters * batchDilution is either True or False; specifies whether periodic dilutions are performed. * dilTime is the periodicity at which dilutions are performed, in hr. * dilFactor is the dilution factor applied. If the value passed here is larger than one, that will be the dilution factor; if it is smaller than one, it will be the applied dilution properly. For instance, a 1:100 dilution can be specified as either 100 or 0.01. Let's first do a batch culture with no oxygen in the environment. import comets as c import os import pandas as pd import cobra as cb pd.options.display.max_rows = 10 # Set relevant parameters b_params = c.params() b_params.all_params['batchDilution'] = True b_params.all_params['dilTime'] = 24 b_params.all_params['dilFactor'] = 100 b_params.all_params['timeStep'] = .2 b_params.all_params['maxCycles'] = 400 # Set layout b_layout = c.layout('test_batch/batch_layout') b_layout.media.loc[b_layout.media['metabolite'] == 'glc__D_e', 'init_amount'] = 20 b_layout.media.loc[b_layout.media['metabolite'] == 'o2_e', 'init_amount'] = 0 b_layout.media .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } metabolite init_amount diff_c g_static g_static_val g_refresh 0 o2_e 0.0 NaN 0 0.0 NaN 1 glc__D_e 20.0 NaN 0 0.0 NaN 2 ca2_e 1000.0 NaN 1 1000.0 NaN 3 cbl1_e 1000.0 NaN 1 1000.0 NaN 4 cl_e 1000.0 NaN 1 1000.0 NaN ... ... ... ... ... ... ... 20 sel_e 1000.0 NaN 1 1000.0 NaN 21 slnt_e 1000.0 NaN 1 1000.0 NaN 22 so4_e 1000.0 NaN 1 1000.0 NaN 23 tungs_e 1000.0 NaN 1 1000.0 NaN 24 zn2_e 1000.0 NaN 1 1000.0 NaN 25 rows \u00d7 6 columns Now, run simulation and draw the biomass curve. # create comets object from the loaded parameters and layout batch_anaerob = c.comets(b_layout, b_params) # run comets simulation batch_anaerob.run() Running COMETS simulation ... Done! batch_anaerob.total_biomass.plot(x = 'cycle', y = 'iJO1366') Here, we see that the population is unable to reach enough density in a single cycle to maintain a stable population, an is therefore going to extinction. Lets now add oxygen to the environment, and redo the simulation. b_layout.media.loc[b_layout.media['metabolite'] == 'o2_e', 'init_amount'] = 1000 # create comets object from the loaded parameters and layout batch_aerob = c.comets(b_layout, b_params) # run comets simulation batch_aerob.run() Running COMETS simulation ... Done! batch_aerob.total_biomass.plot(x = 'cycle', y = 'iJO1366') Now, with oxygen in the environment enabling respiration, the growth rate is much higher, and the population soon reaches stationnary phase, maintaining the population through the successive dilutions.","title":"Batch culture in COMETS"},{"location":"python-module/deprecated/model_testing/","text":"Loading models and CobraPy compatibility Let's show with a couple of simple simulation how the COMETS Python toolbox deals with models, including compatibility with CobraPy. We first create a set of parameters by instantiating the params class (with no arguments, meaning that all parameter values will be the default). and a layout containing a simple environment with glucose as the only carbon source. import comets as c import os import pandas as pd import matplotlib.pyplot as plt pd.options.display.max_rows = 10 # .. Create set of parameters with default values, and change timeStep my_params = c.params() my_params.all_params['timeStep'] = 0.25 # .. Load layout from file and load cobra model into the layout my_layout = c.layout('test_models/layout_blueprint') We then load in the Cobra SBML iJO1366 model file to the layout. Each time the models in a layout are changed, we have to run also the update_models() method. my_layout.models = ['test_models/iJO1366.xml'] my_layout.update_models() my_layout.models ['iJO1366'] We are now ready toinstantiate the comets class and run the simulation. my_comets = c.comets(my_layout, my_params) my_comets.run() Running COMETS simulation ... Done! biomass1 = my_comets.total_biomass plt.plot('cycle', 'iJO1366', data=biomass1) Adjusting COMETS parameters in models What if we want to change some parameters of the model? For instance, we might want to change the type of optimization of the model to maximize biomass and then minimize the total flux (parsimonious FBA). For manipulating models, we need to load them in SBML format using the COBRA package, and then add the corresponding fields for COMETS (see bottom of this page). import cobra as cb md = cb.io.read_sbml_model('test_models/iJO1366.xml') # add some parameters to the model md.obj_style = 'MAX_OBJECTIVE_MIN_TOTAL' # change the ID of the model md.id = 'modified_iJO1366' We might also want to change V_{max} V_{max} , K_m K_m , and Hill coefficients of some uptake reaction, say glucose uptake. We can add these as fields of the corresponding exchange reaction. However, if we decide to specify these parameters for any particular reaction, we will also need to specify their default values for all the rest of uptake reactions in the model. # Set specific values for the glucose transporter md.reactions.EX_glc__D_e.Vmax = 6 md.reactions.EX_glc__D_e.Km = .1 md.reactions.EX_glc__D_e.Hill = 2 # Set also teh default values for the rest of reactions md.default_vmax = 10 md.default_km = 0.01 md.default_hill = 1 Lets now include this cobra model object in our layout. In addition to passing strings specifying filenames as we did previously, Models can be passed directly as a list of cobra.Model objects to the layout: my_layout.models = [md] my_layout.models [<Model modified_iJO1366 at 0x7f3a2b1c59b0>] NOTE: the list of models can be either a list of model files (either cobra xml or comets models, see below) or a list of cobra models loaded into the environment, but never a mix of both. In order to make effective any changes in the layout models, we have to run update_models : my_layout.update_models() Now, let's run the new model and compare it to the previous simulation. my_comets = c.comets(my_layout, my_params) my_comets.run() biomass2 = my_comets.total_biomass plt.plot('cycle', 'iJO1366', data=biomass1) plt.plot('cycle', 'modified_iJO1366', data=biomass2) Running COMETS simulation ... Done! Makes sense - we made the model worse in glucose by reducing V_{max} V_{max} and increasing K_M K_M . Loading COMETS model files The layout class is also capable of loading model files in COMETS model format ( .cmd , the format passed to the COMETS Java engine). This will be deprecated in the future to simplify things for the user, who will only have to deal with cobra type SBML models. For example, let's include a COMETS model in our previous layout, and run it. my_layout.models = ['test_models/iJO1366.cmd'] my_layout.update_models() my_layout.models ['iJO1366'] my_comets = c.comets(my_layout, my_params) my_comets.run() Running COMETS simulation ... Done! print(my_comets.run_output) -script running script file: /home/djordje/Dropbox/projects/COMETS-Python-Toolbox/.current_script Loading layout file '/home/djordje/Dropbox/projects/COMETS-Python-Toolbox/.current_layout'... Found 1 model files! Loading 'iJO1366.cmd' ... ... [etc] plt.plot('cycle', 'iJO1366', data=my_comets.total_biomass)","title":"Loading models and CobraPy compatibility"},{"location":"python-module/deprecated/model_testing/#loading-models-and-cobrapy-compatibility","text":"Let's show with a couple of simple simulation how the COMETS Python toolbox deals with models, including compatibility with CobraPy. We first create a set of parameters by instantiating the params class (with no arguments, meaning that all parameter values will be the default). and a layout containing a simple environment with glucose as the only carbon source. import comets as c import os import pandas as pd import matplotlib.pyplot as plt pd.options.display.max_rows = 10 # .. Create set of parameters with default values, and change timeStep my_params = c.params() my_params.all_params['timeStep'] = 0.25 # .. Load layout from file and load cobra model into the layout my_layout = c.layout('test_models/layout_blueprint') We then load in the Cobra SBML iJO1366 model file to the layout. Each time the models in a layout are changed, we have to run also the update_models() method. my_layout.models = ['test_models/iJO1366.xml'] my_layout.update_models() my_layout.models ['iJO1366'] We are now ready toinstantiate the comets class and run the simulation. my_comets = c.comets(my_layout, my_params) my_comets.run() Running COMETS simulation ... Done! biomass1 = my_comets.total_biomass plt.plot('cycle', 'iJO1366', data=biomass1)","title":"Loading models and CobraPy compatibility"},{"location":"python-module/deprecated/model_testing/#adjusting-comets-parameters-in-models","text":"What if we want to change some parameters of the model? For instance, we might want to change the type of optimization of the model to maximize biomass and then minimize the total flux (parsimonious FBA). For manipulating models, we need to load them in SBML format using the COBRA package, and then add the corresponding fields for COMETS (see bottom of this page). import cobra as cb md = cb.io.read_sbml_model('test_models/iJO1366.xml') # add some parameters to the model md.obj_style = 'MAX_OBJECTIVE_MIN_TOTAL' # change the ID of the model md.id = 'modified_iJO1366' We might also want to change V_{max} V_{max} , K_m K_m , and Hill coefficients of some uptake reaction, say glucose uptake. We can add these as fields of the corresponding exchange reaction. However, if we decide to specify these parameters for any particular reaction, we will also need to specify their default values for all the rest of uptake reactions in the model. # Set specific values for the glucose transporter md.reactions.EX_glc__D_e.Vmax = 6 md.reactions.EX_glc__D_e.Km = .1 md.reactions.EX_glc__D_e.Hill = 2 # Set also teh default values for the rest of reactions md.default_vmax = 10 md.default_km = 0.01 md.default_hill = 1 Lets now include this cobra model object in our layout. In addition to passing strings specifying filenames as we did previously, Models can be passed directly as a list of cobra.Model objects to the layout: my_layout.models = [md] my_layout.models [<Model modified_iJO1366 at 0x7f3a2b1c59b0>] NOTE: the list of models can be either a list of model files (either cobra xml or comets models, see below) or a list of cobra models loaded into the environment, but never a mix of both. In order to make effective any changes in the layout models, we have to run update_models : my_layout.update_models() Now, let's run the new model and compare it to the previous simulation. my_comets = c.comets(my_layout, my_params) my_comets.run() biomass2 = my_comets.total_biomass plt.plot('cycle', 'iJO1366', data=biomass1) plt.plot('cycle', 'modified_iJO1366', data=biomass2) Running COMETS simulation ... Done! Makes sense - we made the model worse in glucose by reducing V_{max} V_{max} and increasing K_M K_M .","title":"Adjusting COMETS parameters in models"},{"location":"python-module/deprecated/model_testing/#loading-comets-model-files","text":"The layout class is also capable of loading model files in COMETS model format ( .cmd , the format passed to the COMETS Java engine). This will be deprecated in the future to simplify things for the user, who will only have to deal with cobra type SBML models. For example, let's include a COMETS model in our previous layout, and run it. my_layout.models = ['test_models/iJO1366.cmd'] my_layout.update_models() my_layout.models ['iJO1366'] my_comets = c.comets(my_layout, my_params) my_comets.run() Running COMETS simulation ... Done! print(my_comets.run_output) -script running script file: /home/djordje/Dropbox/projects/COMETS-Python-Toolbox/.current_script Loading layout file '/home/djordje/Dropbox/projects/COMETS-Python-Toolbox/.current_layout'... Found 1 model files! Loading 'iJO1366.cmd' ... ... [etc] plt.plot('cycle', 'iJO1366', data=my_comets.total_biomass)","title":"Loading COMETS model files"}]}